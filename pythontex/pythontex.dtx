% \iffalse meta-comment
%
% Copyright (C) 2012 by Geoffrey M. Poore <gpoore@gmail.com>
% ---------------------------------------------------------------------------
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Geoffrey M. Poore.
%
% This work consists of the files pythontex.dtx and pythontex.ins
% and the derived filebase pythontex.sty.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{pythontex.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{pythontex}
%<*package>
    [2012/05/09 Version~0.9beta2 PythonTeX]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage[svgnames]{xcolor}
\usepackage{pythontex}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{colorlinks=true,urlcolor=Green,linkcolor=blue}
\newcommand{\pytxtodo}[1]{}
%\newcommand{\pytxtodo}[1]{\textcolor{red}{TO~DO: \scantokens{#1}}}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{pythontex.dtx}
  \PrintChanges
  \PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{1758}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{Version 0.9beta}{2012/04/27}{Initial public beta release.}
% \changes{Version 0.9beta2}{2012/05/09}{Changed Python output extension to .stdout.}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \newcommand{\pytex}{Python\TeX}
% \GetFileInfo{pythontex.dtx}
% \title{The \textsf{pythontex} package}
% \author{Geoffrey M.\ Poore \\ \url{gpoore@gmail.com}}
% \date{\fileversion~from \filedate}
%
% \maketitle
%
% \begin{abstract}
% \pytex\ allows Python code entered within a \LaTeX\ document to be executed, and the output to be included within the original document.  This provides access to the full power of Python from within \LaTeX, simplifying Python-\LaTeX\ workflow and making possible a range of document customization and automation.  It also allows macro definitions that mix Python and \LaTeX\ code.  In addition, \pytex\ provides syntax highlighting for many programming languages via the Pygments Python package.
%
% \pytex\ is fast and user-friendly.  Python code is only executed when it has been modified.  When code is executed, it automatically attempts to run in parallel.  If Python code produces errors, the error message line numbers are synchronized with the \LaTeX\ document line numbers, so that it is easy to find the misbehaving code.
% \end{abstract}
%
%
% \section*{Warning}
% \pytex\ makes possible some pretty amazing things.  But that power brings with it a certain risk and responsibility.  Compiling a document that uses \pytex\ involves executing Python code on your computer.  You should only compile \pytex\ documents from sources you trust.  \pytex\ comes with NO WARRANTY.\footnote{All \LaTeX\ code is licensed under the \href{http://www.latex-project.org/lppl.txt}{\LaTeX\ Project Public License (LPPL)} and all Python code is licensed under the \href{http://www.opensource.org/licenses/BSD-3-Clause}{BSD 3-Clause License}.} The copyright holder and any additional authors will not be liable for any damages.
%
%
% \section*{Package status}
% \pytex\ is currently in ``beta.''  Almost all features intended for version 0.9 are present, and almost all are fully functional (at least, so far as is known!).  Testing is the main task that remains.  Much of that will involve testing installation and functionality under different operating systems and configurations.  So far, \pytex\ has been developed and tested exclusively under Windows with \TeX\ Live and Python 2.6-2.7.  The full 0.9 release is anticipated around the end of May.
% \vfill
% 
%
% \pagebreak
% \tableofcontents
% \pagebreak
%
%
% \section{Introduction}
%
% \LaTeX\ can do a lot,\footnote{\TeX\ is a Turing-complete language.} but the programming required can sometimes be painful.\footnote{As I learned in creating this package.}  Also, in spite of the many packages available for \LaTeX, the libraries and packages of a general-purpose programming language are lacking.  For these reasons, there have been multiple attempts to allow other languages to be used within \LaTeX.
% \begin{itemize}
% \item \href{http://www.ctan.org/tex-archive/macros/latex/contrib/perltex/}{Perl\TeX} allows the bodies of \LaTeX\ macros to be written in Perl.
% \item \href{http://www.ctan.org/tex-archive/macros/latex/contrib/sagetex/}{Sage\TeX} allows code for the Sage mathematics software to be executed from within a \LaTeX\ document.
% \item Martin R.\ Ehmsen's \href{http://web.archive.org/web/20080728170129/www.imada.sdu.dk/~ehmsen/python.sty }{|python.sty|} provides a very basic method of executing Python code from within a \LaTeX\ document.
% \item \href{http://elec.otago.ac.nz/w/index.php/SympyTeX}{Sympy\TeX} allows more sophisticated Python execution, and is largely based on a subset of Sage\TeX.
% \item \href{http://www.luatex.org/}{Lua\TeX} extends the pdf\TeX\ engine to provide Lua as an embedded scripting language, and as a result yields tight, low-level Lua integration.
% \end{itemize}
%
% \pytex\ attempts to fill a perceived gap in the current integrations of \LaTeX\ with an additional language.  It has a number of objectives, only some of which have been met by previous packages.
% \begin{description}
% \item[Execution speed]\hfill\\ In the approaches mentioned above, all the non-\LaTeX\ code is executed at every compilation of the \LaTeX\ document (Perl\TeX, Lua\TeX, and |python.sty|), or all the non-\LaTeX\ code is executed every time it is modified (Sage\TeX\ and Sympy\TeX).  However, many tasks such as plotting and data analysis take significant time to execute.  We need a way to fine-tune code execution, so that independent blocks of slow code may be separated into their own sessions and are only executed when modified.  If we are going to split code into multiple sessions, we might as well run these sessions in parallel, further increasing speed.  A byproduct of this approach is that it now becomes much more feasible to include slower code, since we can still have fast compilations whenever the slow code isn't modified.
% \item[Compiling without executing]\hfill\\ Even with all of these features to boost execution speed, there will be times when we have to run slow code.  Thus, we need the execution of non-\LaTeX\ code to be separated from compiling the \LaTeX\ document.  We need to be able to edit and compile a document containing unexecuted code.  Unexecuted code should be invisible or be replaced by placeholders.  Sage\TeX\ and Sympy\TeX\ have implemented such a separation of compiling and executing.  In contrast, Lua\TeX\ and Perl\TeX\ execute all the code at each compilation---but that is appropriate given their goal of simplifying macro programming.
% \item[Error messages]\hfill\\ Whenever code is saved from a \LaTeX\ document to an external file and then executed, the line numbers for any error messages will not correspond to the line numbering of the original \LaTeX\ document.  At one extreme, |python.sty| doesn't attempt to deal with this issue, while at the other extreme, Sage\TeX\ uses an ingenous system of |Try|/|Except| statements on every line of code.  We need a system that translates all error messages so that they correspond to the line numbering of the original \LaTeX\ document, with minimal overhead when there are no errors.
% \item[Syntax highlighting]\hfill\\ Once we begin using non-\LaTeX\ code, sooner or later we will likely wish to typeset some of it, which means we need syntax highlighting.  A number of syntax highlighting packages currently exist for \LaTeX; perhaps the most popular are |listings| and |minted|.  |listings| uses pure \LaTeX.  It has not been updated since 2007, which makes it a less ideal solution in some circumstances.  |minted| uses the Python Pygments package to perform highlighting.  Pygments can provide superior syntax highlighting, but |minted| can be slow because all code must be highlighted at each compilation.  We need syntax highlighting via Pygments that saves all highlighted code, only re-highlighting when there are modifications.  Ideally, we would also like a solution that overcomes some of |minted|'s longstanding issues.\footnote{http://code.google.com/p/minted/issues/list}
% \item[Context awareness]\hfill\\ It would be nice for the non-\LaTeX\ code to have at least a minimal awareness of its context in the \LaTeX\ document.  It would be nice to know whether code is executing within math mode, and if so, whether the code is within a paragraph or within a standalone equation.
% \item[Language-independent implementation]\hfill\\ It would be nice to have a system for executing non-\LaTeX\ code that depends very little on the language of the code.  We should not expect to be able to escape all language dependence.  But if the system is designed to be as general as possible, then it may be expanded in the future to support additional languages.
% \item[Printing]\hfill\\ It would be nice for the |print| statement/function,\footnote{In Python, |print| was a statement until Python 3.0, when it became a function.  The function form is available via import from |\textunderscore\textunderscore future\textunderscore\textunderscore| in Python 2.6 and later.} or its equivalent, to automatically return its output within the \LaTeX\ document.  For example, using |python.sty| it is possible to generate some text while in Python, open a file, save the text to it, close the file, and then |\input| the file after returning to \LaTeX.  But it is much simpler to generate the text and |print| it, since the printed content is automatically included in the \LaTeX\ document.  This was one of the things that |python.sty| really got right.
% \item[Pure code]\hfill\\ \LaTeX\ has a number of special characters (|# $ % & ~ _ ^ \ { }|), which complicates the entry of code in a non-\LaTeX\ language since these same characters are common in many languages.  Sage\TeX\ and Sympy\TeX\ delimit all inline code with curly braces (|{}|), but this approach fails in the (somewhat unlikely) event that code needs to contain an unmatched brace.  More seriously, they do not allow the percent symbol |%| (modular arithmetic and string formatting in Sage and Python) to be used within inline code.  Rather, a |\percent| macro must be used instead.  This means that code must (sometimes) be entered as a hybrid between \LaTeX\ and the non-\LaTeX\ language.  Lua\TeX\ is somewhat similar:  ``The main thing about Lua code in a TeX document is this: the code is expanded by TeX before Lua gets to it. This means that all the Lua code, even the comments, must be valid TeX!''\footnote{\url{http://wiki.contextgarden.net/Programming_in_LuaTeX}}
%
% This language hybridization is not terribly difficult to work around in the Sage\TeX\ and Sympy\TeX\ cases, and might even be considered a feature in Lua\TeX\ in some contexts.  But if we are going to create a system for general-purpose access to a non-\LaTeX\ language, we need \textbf{all} valid code to work correctly in \textbf{all} contexts, with no hybridization of any sort required.  We should be able to copy and paste valid code into a \LaTeX\ document, without having to worry about hydridizing it.  Among other things, this means that inline code delimiters other than \LaTeX's default curly braces |{}| must be available.
% \item[Hybrid code]\hfill\\ Although we need a system that allows input of pure non-\LaTeX\ code, it would also be convenient to allow hybrid code, or code in which \LaTeX\ macros may be present and are expanded before the code is executed.  This allows \LaTeX\ data to be easily passed to the non-\LaTeX\ language, facilitating a tighter integration of the two languages and the use of the non-\LaTeX\ language in macro definitions.
% \item[Math and science libraries]\hfill\\ The author decided to create \pytex\ after writing a physics dissertation using \LaTeX\ and realizing how frustrating it can be to switch back and forth between a \TeX\ editor and plotting software when fine-tuning figures.  We need access to a non-\LaTeX\ language like Python, MATLAB, or Mathematica that provides strong support for data analysis and visualization.  To maintain broad appeal, this language should primarily involve open-source tools, should have strong cross-platform support, and should also be suitable for general-purpose programming.
% \end{description}
%
% Python was chosen as the language to fulfill these objectives for several reasons.
% \begin{itemize}
% \item It is open-source and has good cross-platform support.\footnote{Unfortunately, Sage can only run under Windows within a virtual machine at present; otherwise, an extension of Sage\TeX\ might have been tempting.  Then again, for general computing, an approach that utilizes pure Python is probably superior.}
% \item It has a strong set of scientific, numeric, and visualization packages, including \href{http://numpy.scipy.org/}{NumPy}, \href{http://www.scipy.org/}{SciPy}, \href{http://matplotlib.sourceforge.net/}{matplotlib}, and \href{http://sympy.org}{SymPy}.  Much of the initial motivation for \pytex\ was the ability to create publication-quality plots and perform complex mathematical calculations without having to leave the \TeX\ editor.
% \item We need a language that is suitable for scripting.  Lua is already available via Lua\TeX, and in any case lacks the math and science tools.\footnote{One could use \href{http://labix.org/lunatic-python}{Lunatic Python}, and some numeric packages for Lua are \href{http://numlua.luaforge.net/}{in development}.}  Perl is already available via Perl\TeX, although Perl\TeX's emphasis on Perl for macro creation makes it rather unsuitable for scientific work using the \href{http://pdl.perl.org/}{Perl Data Language (PDL)} or for more general programming.  Python is one logical choice for scripting.
% \end{itemize}
%
% Now at this point there will almost certainly be some reader, sooner or later, who wants to object, ``But what about language \textit{X}!''  Well, yes, in some respects the choice to use Python did come down to personal preference.  But you should give Python a try, if you haven't already.  You may also wish to consider the many interfaces that are available between Python and other languages.  If you still aren't satisfied, keep in mind \pytex's ``language-independent'' implementation!  Although \pytex\ is written to support Python within \LaTeX, the implementation has been specially crafted so that other languages may be supported in the future.  See Section~\ref{sec:future} for more details.
%
%
%
% \section{Installing and running}
%
% \subsection{Installing \pytex} 
%
% \pytex\ requires a \TeX\ installation.  \href{http://www.tug.org/texlive/}{\TeX\ Live} or \href{http://miktex.org/}{MiK\TeX} are preferred.  \pytex\ requires the |Kpathsea| library, which is available in both of these distributions.  The following \LaTeX\ packages, with their dependencies, are also required:  |fancyvrb|, |etex|, |etoolbox|, |xstring|, |pgfopts|, |makecmds|, |newfloat|, and |xcolor|.  If you are creating and importing graphics using Python, you will also need |graphicx|.  The |mdframed| package is recommended for enclosing typeset code in boxes with fancy borders and/or background colors.
%
% \pytex\ also requires a \href{http://www.python.org/}{Python} installation.  Python 2.7 is recommended for the greatest compatibility with scientific tools, but Python 2.6 and 3.x should work as well.  The Python package \href{http://pygments.org/}{Pygments} must be installed for syntax highlighting to function.  \pytex\ has been tested with Pygments 1.4 and later.  For scientific work, or to compile or experiment with the \pytex\ gallery file, the following are also recommended:  \href{http://numpy.scipy.org/}{NumPy}, \href{http://www.scipy.org/}{SciPy}, \href{http://matplotlib.sourceforge.net/}{matplotlib}, and \href{http://sympy.org}{SymPy}. 
%
% \pytex\ consists of the following files:
% \begin{itemize}
% \item Installer file |pythontex.ins|
% \item Documented \LaTeX\ source file |pythontex.dtx|, from which |pythontex.pdf| and |pythontex.sty| are generated
% \item Main Python script |pythontex.py|
% \item Helper scripts |pythontex_utils.py| and |pythontex_types.py|
% \item Installation script |pythontex_win_install_texlive| (Windows with \TeX\ Live only)
% \item README
% \item Optional batch file |pythontex.bat| for use in launching |pythontex.py| under Windows 
% \end{itemize}
% The style file |pythontex.sty| may be generated by running \LaTeX\ on |pythontex.ins|.  The documentation you are reading may be generated by running \LaTeX\ on |pythontex.dtx|.
%
% Until \pytex\ is submitted to CTAN, it must be installed manually.  The \pytex\ files should be installed within the \TeX\ directory structure as follows.
% \begin{itemize}
% \item \meta{\TeX\ tree root}|/doc/latex/pythontex/|
%     \begin{itemize}
%     \item |pythontex.pdf|
%     \item |README|
%     \end{itemize}
% \item \meta{\TeX\ tree root}|/scripts/pythontex/|
%     \begin{itemize}
%     \item |pythontex.py|
%     \item |pythontex_types.py|
%     \item |pythontex_utils.py|
%     \end{itemize}
% \item \meta{\TeX\ tree root}|/source/latex/pythontex/|
%     \begin{itemize}
%     \item |pythontex.dtx|
%     \end{itemize}
% \item \meta{\TeX\ tree root}|/tex/latex/pythontex/|
%     \begin{itemize}
%     \item |pythontex.sty|
%     \end{itemize}
% \end{itemize}
% After the files are installed, the system must be made aware of their existence.  Run |mktexlsr| or |texhash| to do this.  In order for |pythontex.py| to be executable, a symlink (\TeX\ Live under Linux), launching wrapper (\TeX\ Live under Windows), or batch file (general Windows) should be created in the |bin/| directory.  For \TeX\ Live under Windows, simply copy |bin/win32/runscript.exe| to |bin/win32/pythontex.exe| to create the wrapper.\footnote{See the output of |runscript -h| under Windows for additional details.}
%
% A Python installation script is provided for use with \TeX\ Live under Windows.  It may need to be slightly modified based on your system.  It performs all steps described above.
%
% \subsection{Compiling documents using \pytex}
%
% To compile a document that uses \pytex, you should run \LaTeX, then run |pythontex.py| (preferably via a symlink, wrapper, or batch file, as described above), and finally run \LaTeX\ again.  |pythontex.py| requires a single command-line argument, which must be passed to it directly or via symlink/wrapper/batch file:  the name of the .tex file.  The filename can be passed with or without the .tex extension, but no extension is preferred.\footnote{|pythontex.py| will be happy to work with a file that does not have the .tex extension, so long as the file cooperates with |pythontex.sty|.  In this case, the file extension should \textbf{not} be passed to |pythontex.py|, because it won't be expecting it and won't be able to determine that it is indeed an extension.  |pythontex.py| just needs to know |\textbackslash jobname|.}  The file name should be wrapped in double quotes |"| to allow for space characters.\footnote{Using spaces in the names of .tex files is apparently frowned upon.  But if you configure things to handle spaces whenever it doesn't take much extra work, then that's one less thing that can go wrong.}  For example, under Windows with \TeX\ Live we would create the wrapper |pythontex.exe|.  Then we could run \pytex\ on a file \meta{file~name}.tex using the command |pythontex.exe "|\meta{file~name}|"|.  In practice, you will probably want to configure your \TeX\ editor with a shortcut key for running \pytex.
%
% \pytex\ attempts to check for a wide range of errors and return meaningful error messages.  But due to the interaction of \LaTeX\ and Python code, some strange errors are possible.  If you cannot make sense of errors when using \pytex, the simplest thing to try is deleting all files created by \pytex, then recompiling.  By default, these files are stored in a directory called |pythontex-files-|\meta{jobname}, in the same directory as your .tex document.  See Section \ref{sec:troubleshooting} for more details regarding Troubleshooting.
%
%
% \section{Usage}
%
% \subsection{Package options}
% Package options may be set in the standard manner when the package is loaded:
% \begin{quote}
% |\usepackage|\oarg{options}|{pythontex}|
% \end{quote}
%
% \DescribeMacro{autoprint=\meta{none}/true/false default:true \meta{none}=true}
%
% Whenever a |print| command/statement is used, the printed content will automatically be included in the document, unless the code doing the printing is being typeset.  In that case, the printed content must be included using the |\printpythontex| or |\stdoutpythontex| commands, or one of their variants.
%
% Printed content is pulled in directly from the external file in which it is saved, and is interpreted by \LaTeX\ as \LaTeX\ code.  If you wish to avoid this, you should print appropriate \LaTeX\ commands with your content to ensure that it is typeset as you desire.  Alternatively, you may use |\printpythontex| or |\stdoutpythontex| to bring in printed content in verbatim form, using those commands' optional |verb| and |inlineverb| options.
%
% \pagebreak\pytxtodo{Edit page break}
% \DescribeMacro{fixlr=\meta{none}/true/false default:true \meta{none}=true}
%
% This option fixes extra spacing around |\left| and |\right| in math mode.  See the implementation for details.
%
% \DescribeMacro{keeptemps=\meta{none}/all/code/none default:none \meta{none}=all} 
%
% When \pytex\ runs, it creates a number of temporary files.  By default, none of these are kept.  The |none| option keeps no temp files, the |code| option keeps only code temp files (these can be useful for debugging), and the |all| option keeps all temp files (code, stdout and stderr for each code file, etc.).  Note that this option does not apply to any user-generated content, since \pytex\ knows very little about that; it only applies to files that \pytex\ automatically creates by itself.
%
% \DescribeMacro{pygments=\meta{none}/true/false default:false \meta{none}=true} 
%
% This allows the user to determine at the document level whether code is typeset using Pygments rather than the default |fancyvrb|.  Note that the package-level Pygments option can be overridded for individual command and environment families, using the |\setpythontexformatter| macro.\pytxtodo{Add |\setpygmentsformatter| when ready}
%
% \DescribeMacro{pygopt=\marg{pygments~options} default:\meta{none}} 
%
% This allows Pygments options to be set at the document level.  The options must be enclosed in curly braces |{}|.  Currently, three options may be passed in this manner:  |style=|\meta{style~name}, which sets the formatting style; |texcomments|, which allows \LaTeX\ in code comments to be rendered; and |mathescape|, which allows \LaTeX\ math mode (|$...$|) in comments.  The |texcomments| and |mathescape| options may be used with an argument (for example, |texcomments=True/False|); if an argument is not supplied, |True| is assumed.  Example:   |pygopt={style=colorful, texcomments=True, mathescape=False}|.
%
% Pygments options for individual command and environment families may be set with the |\setpythontexpygopt| macro.\pytxtodo{Pygments version!}  These individual settings are always overridden by the package option.
%
% \DescribeMacro{pygextfile=\meta{none}/\meta{integer} default:$\infty$ \meta{none}=25} 
%
% This option speeds the typesetting of long blocks of code using Pygments, at the expense of creating additional external files (in the \pytex\ folder).  The \meta{integer} determines the number of lines of code at which the system starts using multiple external files, rather than a single external file.  See the implementation for the technical details.  In most situations, this option should either not be needed, or should be fine with the default value or similar ``small'' integers.
%
%
% \subsection{Code commands and environments}
%
% \pytex\ provides four types of commands for use with inline code and three environments for use with multiple lines of code.  All commands and environments are named based on a base name and a command- or environment-specific suffix.  A complete set of commands and environments with the same base name constitutes a \textbf{command and environment family}.  In what follows, we describe the different commands and environments, using the |py| base name (the |py| family) as an example.
%
% All commands and environments take a session name as an optional argument.  The session name determines the session in which the code is executed.  This allows code to be executed in multiple independent sessions, increasing speed (sessions run in parallel) and preventing naming conflicts.  If a session is not specified, then the |default| session is used.  Session names should use the characters a-z, A-Z, 0-9, the hyphen, and the underscore; all characters used \textbf{must} be valid in file names, since session names are used to create temporary files.  The colon is also allowed, but it is replaced with an underscore internally, so the sessions |code:1| and |code_1| are identical.
%
% In addition, all environments take |fancyvrb| settings as a second, optional argument.  See the \href{http://www.ctan.org/tex-archive/macros/latex/contrib/fancyvrb}{|fancyvrb| documentation} for an explanation of accepted settings.  This second optional argument \textbf{must} be preceeded by the first optional argument (session name).  If a named session is not desired, the optional argument can be left empty (|default| session), but the square brackets |[]| must be present so that the second optional argument may be correctly identified:
% \begin{quote}
% |\begin{|\meta{environment}|}[]|\oarg{fancyvrb~settings}
% \end{quote}
%
%
% \subsubsection{Inline commands} 
% \pytxtodo{Fix spacing around |\DescribeMacro|!}
% Inline commands are suitable for single lines of code that need to be executed within the body of a paragraph or within a larger body of text.  The commands use arbitrary code delimiters (like |\verb| does), which allows the code to contain arbitrary characters.  Note that this only works properly when the inline commands are \textbf{not} inside other macros.  If an inline command is used within another macro, the code will be read by the other macro before \pytex\ can read the special code characters (that is, \LaTeX\ will try to expand the code).  The inline commands can work properly within other macros, but only when all that they contain is also valid \LaTeX\ code (and you should stick with curly braces for delimiters in this case).
%
% \DescribeMacro{\py\oarg{session}\meta{opening~delim}\meta{code}\meta{closing~delim}}
%
% This command is used for including variable values or other content that can be converted to a string.  It is an alternative to including content via the |print| statement/function within other commands/environments.
%
% The |\py| command sends \meta{code} to Python, and Python returns the result of |str(|\meta{code}|)| to \LaTeX.\footnote{|str()| is a built-in Python function that returns a string representation of its argument.}  \meta{opening~delim} and \meta{closing~delim} must be either a pair of identical, non-space characters, or a pair of curly braces.  Thus, |\py{1+1}| sends the code |1+1| to Python, Python evaluates |str(1+1)|, and the result is returned to \LaTeX\ and included as |2|.  The commands |\py#1+1#| and |\py@1+1@| would have the same effect.  The command can be used to access variable values.  For example, if the code |a=1| had been executed previously, then |\py{a}| simply brings the value of |a| back into the document as |1|.  
%
%Assignment is \textbf{not} allowed using |\py|.  For example, |\py{a=1}| is \textbf{not} valid.  This is because assignment cannot be done within |str()|.
%
% The text returned by Python must be valid \LaTeX\ code.  If you need to include complex text within your document, or if you need to include verbatim text, you should use the |print| statement/function within one of the other commands or environments.  The primary reason to use |\py| rather than |print| is that |print| requires an external file to be created for every command or environment in which it is used, while |\py| and equivalents for other families share a single external file.  Thus, use of |\py| minimizes the creation of external files, which is a key design goal for \pytex.\footnote{For |\textbackslash py|, the text returned by Python is stored in macros and thus must be valid \LaTeX\ code, because \LaTeX\ interprets the returned content.  The use of macros for storing returned content means that an external file need not be created for each use of |\textbackslash py|.  Rather, all macros created by |\textbackslash py| and equivalent commands from other families are stored in a single file that is inputted.}
%
% \DescribeMacro{\pyc\oarg{session}\meta{opening~delim}\meta{code}\meta{closing~delim}}
%
% This command is used for executing but not typesetting \meta{code}.  The suffix  |c| is an abbreviation of |code|.  If the |print| statement/function is used within \meta{code}, printed content will be included automatically so long as the package |autoprint| option is set to true (which is the default setting).
%
% \DescribeMacro{\pyv\oarg{session}\meta{opening~delim}\meta{code}\meta{closing~delim}}
%
% This command is used for typesetting but not executing \meta{code}.  The suffix |v| is an abbreviation for |verbatim|.
%
% \DescribeMacro{\pyb\oarg{session}\meta{opening~delim}\meta{code}\meta{closing~delim}}
%
% This command both executes and typesets \meta{code}.  Since it is unlikely that the user would wish to typeset code and then \textbf{immediately} include any output of the code, printed content is \textbf{not} automatically included, even when the package |autoprint| option is set to true.  Rather, any printed content is included at a user-designated location via the |\printpythontex| macro.  For more details, see the extended discussion of printing, below.
%
%
% \subsubsection{Environments}
%
% \DescribeEnv{pycode~\oarg{session}\oarg{fancyvrb~settings}}
%
% This environment encloses code that is executed but not typeset.  The second optional argument \meta{fancyvrb~settings} is irrelevant since nothing is typeset, but it is accepted to maintain parallelism with the |verb| and |block| environments.  If the |print| statement/function is used within the environment, printed content will be included automatically so long as the package |autoprint| option is set to true (which is the default setting).
%
%
% \DescribeEnv{pyverb~\oarg{session}\oarg{fancyvrb~settings}}
%
% This environment encloses code that is typeset but not executed.  The suffix |verb| is an abbreviation for |verbatim|.
%
%
% \DescribeEnv{pyblock~\oarg{session}\oarg{fancyvrb~settings}}
%
% This environment encloses code that is both executed and typeset.  Since it is unlikely that the user would wish to typeset code and then \textbf{immediately} print any output of the code, printed content is \textbf{not} automatically included, even when the package |autoprint| option is set to true.  Rather, any printed content is included at a user-designated location via the |\printpythontex| macro.  For more details, see the extended discussion of printing, below.
%
%
% \subsubsection{Default families}
%
% By default, three command and environment families are defined.
% \begin{itemize}
% \item Python
%	\begin{itemize}
%	\item Base name |py|: |\py|, |\pyc|, |\pyv|, |\pyb|, |pycode|, |pyverb|, |pyblock|
%	\item Imports:  None.
%	\end{itemize}
% \item Python + pylab (matplotlib module)
%	\begin{itemize}
%	\item Base name |pylab|:  |\pylab|, |\pylabc|, |\pylabv|, |\pylabb|, |pylabcode|, |pylabverb|, |pylabblock|
%	\item Imports:  matplotlib's pylab module, which provides access to much of matplotlib and NumPy within a single namespace.  pylab content is brought in via |from pylab import *|.
%	\end{itemize}
% \item Python + SymPy
%	\begin{itemize}
%	\item Base name |sympy|: |\sympy|, |\sympyc|, |\sympyv|, |\sympyb|, |sympycode|, |sympyverb|, |sympyblock|
%	\item Imports:  SymPy via |from sympy import *|.
%	\item Other notes:  |\sympy| output is automatically processed using SymPy's |latex()| function.  To turn this off, use the command
% \begin{quote}
% |pytex.use_sympy_latex_printer=False|
% \end{quote}
%	\end{itemize}
% \end{itemize}
%
% By default, all families will use all applicable |__future__| imports under Python 2.6-7 (currently, |division| and |print_function| are brought it, but the rest will be added soon).\pytxtodo{Revise imports}  All families also import |pythontex_utils.py| under the |pytex| namespace (|import pythontex_utils as pytex|).  This provides various utilities for interfacing with \LaTeX.
%
%
% \subsubsection{Formatting}
%
% \DescribeMacro{\setpythontexfv\oarg{family}\marg{fancyvrb~settings}}
%
% This command sets the |fancyvrb| settings for all command and environment families.  Alternatively, if an optional argument \meta{family} is supplied, the settings only apply to the family with that base name.  The general command will override family-specific settings.
%
% Each time the command is used, it completely overwrites the previous settings.  If you only need to change the settings for a few pieces of code, you should use the second optional argument in |block| and |verb| environments.
%
% Note that |\setpythontexfv| and |\setpygmentsfv| are equivalent when they are used without an optional argument; in that case, either may be used to determine the document-wide |fancyvrb| settings, because both use the same underlying macro.
%
%
% \DescribeMacro{\setpythontexformatter\marg{family}\marg{formatter}}
%
% This allows the formatter used by \meta{family} to be set.  Valid options for \meta{formatter} are |auto|, |fancyvrb|, and |pygments|.  Using |auto| means that the formatter will be determined based on the package |pygments| option.  Using either of the other two options will force \meta{family} to use that formatter, regardless of the package-level options.
%
%
% \DescribeMacro{\setpythontexpyglexer\marg{family}\marg{pygments~lexer}}
%
% This allows the Pygments lexer to be set for \meta{family}.  \meta{pygments~lexer} should should use a form of the lexer name that does not involve any special characters.  For example, you would want to use the lexer name |csharp| rather than |C#|.  This should not be an issue except when using Pygments commands and environments to typeset code of an arbitrary language.
%
% \DescribeMacro{\setpythontexpygopt\marg{family}\marg{pygments~options}}
%
% This allows the Pygments options for \meta{family} to be redefined.  Note that any previous options are overwritten.  The same Pygments options may be passed here as are available via the package |pygopt| option.  Note that for each available option, individual family settings will be overridden by the package-level |pygopt| settings, if any are given.
%
%
% \DescribeMacro{\setpythontexmacros\oarg{formatter}\marg{family}\marg{pygments~lexer}\marg{pygments~options}}
%
% This allows all family settings to be modified at once, giving access to the power of |\setpythontexformatter|, |\setpythontexpyglexer|, and |\setpythontexpygopt| via a single command.
%
%
%
% \subsubsection{Access to printed content (stdout)}
%
% The following macros allow access to printed content and any additional content that is written to stdout.  Two identical forms are provided for each macro:  one based off of the word |print| and one based off of |stdout|.  Macro choice depends on user naming preference.  The |stdout| form provides parallelism for the |\stderrpythontex| command and associated macros that will be present in an upcoming release.  Those macros will provide access to error messages sent to stderr.
%
% \DescribeMacro{\printpythontex\oarg{verbatim~options}\oarg{fancyvrb~options}}
%
% \DescribeMacro{\stdoutpythontex\oarg{verbatim~options}\oarg{fancyvrb~options}}
%
% Unless the package option |autoprint| is true, printed content from |code| commands and environments will not be automatically included.  Even when the |autoprint| option is turned on, |block| commands and environments do not automatically include printed content, since we will generally not want printed content immediately after typeset code.  This macro brings in any printed content from the \textbf{last} command or environment.  It is reset after each command/environment (except after |verb| commands and environments that are typeset using |fancyvrb|), so its scope for accessing particular printed content is very limited.  It will return an error if no printed content exists.
%
% Printed content is pulled in directly from the external file in which it is saved, and is interpreted by \LaTeX\ as \LaTeX\ code.  If you wish to avoid this, you should print appropriate \LaTeX\ commands with your content to ensure that it is typeset as you desire.  Alternatively, you may consider the |verb| and |inlineverb| options, which bring in code verbatim.  If code is brought in verbatim, then \meta{fancyvrb~options} are applied to it.
%
%
% \DescribeMacro{\saveprintpythontex\marg{name}}
% 
% \DescribeMacro{\savestdoutpythontex\marg{name}}
%
% \DescribeMacro{\useprintpythontex\oarg{verbatim~options}\oarg{fancyvrb~options}\marg{name}}
%
% \DescribeMacro{\usestdoutpythontex\oarg{verbatim~options}\oarg{fancyvrb~options}\marg{name}}
%
% We may wish to be able to access the printed content from a command or environment at any point after the code that prints it, not just before any additional commands or environments are used.  In that case, we may save access to the content under \meta{name}, and access it later via |\useprintpythontex|\marg{name}.  \meta{verbatim~options} must be either |verb| or |inlineverb|, specifying how content is brought in verbatim.  If content is brought in verbatim, then \meta{fancyvrb~options} are applied.
%
%
%
% \subsection{Pygments commands and environments}
%
% Although \pytex's goal is primarily the execution and typesetting of Python code from within \LaTeX, it also provides access to syntax highlighting for any language supported by Pygments.
%
% \DescribeMacro{\pygment\marg{lexer}\marg{code}}
% 
% This command typesets \meta{code} in a suitable form for inline use within a paragraph, using the Pygments lexer \meta{lexer}.
%
% As with the inline commands for code typesetting and execution, there is not an optional argument for |fancyvrb| settings, since almost all of them are not relevant for inline usage, and the few that might be should probably be used document-wide if at all.
%
%
% \DescribeEnv{pygments~\oarg{fancyvrb~settings}\marg{lexer}}
%
% This environment typesets its contents using the Pygments lexer \meta{lexer} and applying the |fancyvrb| settings \meta{fancyvrb~settings}.
%
% 
% \DescribeMacro{\inputpygments\oarg{fancyvrb~settings}\marg{lexer}\marg{external-file}}
%
% This command brings in the contents of \meta{external-file}, highlights it using \meta{lexer}, and typesets it using \meta{fancyvrb~settings}.  
%
%
% \DescribeMacro{\setpygmentsfv\oarg{lexer}\marg{fancyvrb~settings}}
%
% This command sets the \meta{fancyvrb~settings} for \meta{lexer}.  If no \meta{lexer} is supplied, then it sets document-wide \meta{fancyvrb~settings}.  In that case, it is equivalent to |\setpythontexfv|\marg{fancyvrb~settings}.
%
%
% \DescribeMacro{\setpygmentspygopt\marg{lexer}\marg{pygments~options}}
%
% This sets \meta{lexer} to use \meta{pygments~options}.  If there is any overlap between \meta{pygments~options} and the package-level |pygopt|, the package-level options override the lexer-specific options.
%
% 
% \DescribeMacro{\setpygmentsformatter}
%
% \DescribeMacro{\setpygmentsmacros}
% 
% Pygments equivalents of the corresponding Python commands are coming soon.\pytxtodo{Describe}
%
%
% \subsection{General code typesetting}
%
% \subsubsection{Listings float}
%
% \DescribeEnv{listing}
%
% \pytex\ will create a float |listing| for code listings, unless an environment with that name already exists.  The |listing| environment is created using the |newfloat| package.  Customization is possible through |newfloat|'s |\SetupFloatingEnvironment| command.
%
% \DescribeMacro{\setpythontexlistingenv\marg{alternate~listing~environment~name}}
%
% In the event that an environment named |listing| already exists for some other purpose, \pytex\ will not override it.  Instead, you may set an alternate name for \pytex's |listing| environment, via |\setpythontexlistingenv|.
%
%
% \subsubsection{Background colors}
%
% \pytex\ uses |fancyvrb| internally to typeset all code.  Using |fancyvrb|, it is possible to set background colors for individual lines of code, but not for entire blocks of code, using |\FancyVerbFormatLine| (you may also wish to consider the |formatcom| option).   For example, the following command puts a green background behind all the characters in each line of code:
% \begin{verbatim}
% \renewcommand{\FancyVerbFormatLine}[1]{\colorbox{green}{#1}}
% \end{verbatim}
%
% If you need a completely solid colored background for an environment, or a highly customizable background, you should consider the |mdframed| package.  Preliminary tests show that wrapping \pytex\ environments with |mdframed| frames works quite well.  You can even automatically add a particular style of frame to all instances of an environment using the command
% \begin{quote}
% |\surroundwithmdframed|\oarg{frame~options}\marg{environment}
% \end{quote}
% Or you could consider using |etoolbox| to do the same thing with |mdframed| or another framing package of your choice, via |etoolbox|'s |\BeforeBeginEnvironment| and |\AfterEndEnvironment| macros.
%
%
% \subsubsection{Referencing code by line number}
%
% It is possible to reference individual lines of code, by line number.  If code is typeset using pure |fancyvrb|, then \LaTeX\ labels can be included within comments.  The labels will only operate correctly (that is, be treated as \LaTeX\ rather than verbatim content) if |fancyvrb|'s |commandchars| option is used.  For example, |commandchars=\\\{\}| makes the backslash and the curly braces function normally \textbf{within} |fancyvrb| environments, allowing \LaTeX\ macros to work, including label definitions.  Once a label is defined within a code comment, then referencing it will return the code line number.
%
% The disadvantage of the pure |fancyvrb| approach is that by making the backslash and curly braces command characters, we can produce conflicts if the code we are typesetting contains these characters for non-\LaTeX\ purposes.  In such a case, it might be possible to make alternate characters command characters.
%
% If code is typeset using Pygments (which also ties into |fancyvrb|), then this problem is avoided.  The Pygments option |texcomments=true| has Pygments look for \LaTeX\ code only within comments.  Possible command character conflicts with the language being typeset are thus avoided.
%
% Note that when references are created within comments, the references themselves will be invisible within the final document but the comment character(s) and any other text within comments will still be visible.  For example, the following
% \begin{quote}
% |abc=123 #This is a very important line of code!\ref{lst:important}|
% \end{quote}
% would appear as
% \begin{quote}
% |abc=123 #This is a very important line of code!|
% \end{quote}
% If a comment only contains the |\ref| command, then only the comment character |#| would actually be visible in the typeset code.
%
% \subsection{Advanced \pytex\ usage}
%
% \DescribeMacro{\restartpythontexsession\marg{counter~value(s)}}
%
% This macro determines when or if sessions are restarted (or ``subdivided'').  Whenever  \meta{counter~value(s)} change, the session will be restarted.
%
% By default, each session corresponds to a single code file that is executed.  But sometimes it might be conventient if the code from each chapter or section or subsection were to run within its own file.  For example, we might want each chapter to execute separately, so that changing code within one chapter won't require that all the code from all the other chapters be executed.  But we might not want to have to go to the bother and extra typing of defining a new session for every chapter (like |\py[ch1]{|\meta{code}|}|).  To do that, we could use |\restartpythontexsession{\thechapter}|.  This would cause all sessions to restart whenever the chapter counter changes.  If we wanted sessions to restart at each section within a chapter, we would use |\restartpythontexsession{\thechapter|\meta{delim}|\thesection}|.  \meta{delim} is needed to separate the counter values so that they are not ambiguous (for example, we need to distinguish chapter 11.1 from chapter 1.11).  \meta{delim} should be a hyphen or an underscore; it must be a character that is valid in file names.
%
% Note that \textbf{counter values}, and not counters themselves, must be supplied as the argument.  Also note that the command applies to \textbf{all} sessions.  If it did not, then we would have to keep track of which sessions restarted when, and the lack of uniformity could easily result in errors on the part of the user.
%
% Keep in mind that when a session is restarted, all continuity is lost.  It is best not to restart sessions if you need continuity.  If you must restart a session, but also need to keep some data, you could save the data before restarting the session and then load the saved data after the restart.  This approach should be used with \textbf{extreme} caution, since it can result in unanticipated errors due to sessions not staying synchronized.\footnote{For example, suppose sessions are restarted based on chapter.  |session-ch1| saves a data file, and |session-ch2| loads it and uses it.  You write the code, and run \pytex.  Then you realize that |session-ch1| needs to be modified and make some changes.  The next time \pytex\ runs, it will only execute |session-ch1|, since it detects no code changes in |session-ch2|.  This means that |session-ch2| is not updated, at least to the extent that it depends on the data from |session-ch1|.  Again, saving and loading data between restarted sessions, or just between sessions in general, can produce unexpected behavior and should be avoided.}
%
% This command can only be used in the preamble.
%
% \DescribeMacro{\setpythontexoutputdir\marg{output~directory}}
%
% By default, \pytex\ saves all created content in a directory called |pythontex-files-|\meta{sanitized jobname}, where \meta{sanitized jobname} is just |\jobname| with any space characters or asterisks replaced with hyphens.  This directory will be created by |pythontex.py|.  If we wish to specify another directory (for example, if |\jobname| is long and complex, and there is no danger of two files trying to use the same directory), then we can use the |\setpythontexoutputdir| macro to redefine the output directory.
%
%
% \section{Questions and answers}
%
% \begin{description}[style=unboxed]
% \item[Will you add a plot command that automates the saving and inclusion of plots or other graphics?] There are no plans to add a plot command like |\pyplot|.  A plot command would add a little convenience, but at the expense of power.
% \end{description}
%
%
%
% \section{Troubleshooting}
% \label{sec:troubleshooting}
%
% A more extensive troubleshooting section will be added in the future.\pytxtodo{Extend section}
%
% If a \pytex\ document will not compile, you may want to delete the directory in which \pytex\ content is stored and try compiling from scratch.  It is possible for \pytex\ to become stuck in an unrecoverable loop.  Suppose you tell Python to print some \LaTeX\ code back to your \LaTeX\ document, but make a fatal \LaTeX\ syntax error in the printed content.  This syntax error prevents \LaTeX\ from compiling.  Now suppose you realize what happened and correct the syntax error.  The problem is that the corrected code cannot be executed until \LaTeX\ correctly compiles and saves the code externally, but \LaTeX\ cannot compile until the corrected code has already been executed.  The simplest solution in such cases is to correct the code, delete all files in the \pytex\ directory, compile the \LaTeX\ document, and then run \pytex\ from scratch.
%
% 
% \pytex\ has not been tested for UTF8 output (XeTeX etc.), but it is expected that this can be added in the future.
%
% Dollar signs \$ may appear as \textsterling\ in italic code comments typeset by Pygments.  This is a font-related issue.  One fix is to |\usepackage[T1]{fontenc}|.
%
%
% \section{The future of \pytex}
% \label{sec:future}
%
% This section consists of a To Do list and a roadmap for future development.  The To Do list is primarily for the benefit of the author, but also gives users a sense of what changes are in progress.  The roadmap provides a projected direction for future development.
%
% \subsection{To Do}
%
% \subsubsection{Modifications to make}
% \begin{itemize}
% \item More testing and abstraction of Windows installer script.
% \item User-defined custom commands and environments for general Pygments typesetting.
% \item Allow \LaTeX\ in code, and expand \LaTeX\ macros before passing code to |pythontex.py|.  Maybe create an additional set of inline commands with additional |exp| suffix for |expanded|?
% \item Better handling of temp files by |pythontex.py|.  Currently, not all temp files will necessarily be deleted automatically (especially extra, per-instance Pygments files).  There needs to be a list of every created file.
% \item Check for possible file input collisions due to |.pygtex|.  |\input{*.tex}|?
% \item Testing under Linux.
% \item ``Proper'' documentation for the Python code (Sphinx?).
% \item Establish a testing framework.
% \item Clarify whether error checking for various user input (options, etc.) is done on the \TeX\ or Python sides.
% \item Refine |pythontex_utils.py| interface, function names?
% \item Beamer compatibility.  Any way to do \href{http://tex.stackexchange.com/questions/26917/beamer-vs-minted-overlays}{this}?
% \item Add a way to disable the creation of default families?
% \item Add a way to enable/disable |__future__| imports?  Also, automatically import all future modules that are relevant given Python version, unless otherwise instructed.
% \item |\edef| group info at the start of macros, in case it changes before printing content?
% \item Cleanup if outputdir changes?  Probably should let the user know, but leave it to the user to actually delete anything.
% \item Decide on renaming ``group'' in internals.
% \item Revise name existence checking macros?
% \item Keep track of any Pygments errors for future runs, so we know what to run again?  How easy is it to get Pygments errors?  There don't seem to have been any in any of the testing so far.
% \item Add a way to access |stderr|, so that incorrect code examples can be typeset along with their error output.
% \item Refine printing error messages.
% \item Refine/create |\setpygmentsmacros| and |\setpygmentsformatter|.
% \item It would be nice to include some shortcut functions within the |pytex| namespace for the purpose of setting SymPy and Pylab precision.  Also, it would be nice to have shortcuts for \href{https://github.com/nschloe/matplotlib2tikz}{Matplotlib2tikz} integration.
% \item Consider expanding functionality of |\|\meta{basename} so that assignment is allowed, basically making its functionality more similar to that of a Python shell like IDLE.
% \end{itemize}
%
% \subsubsection{Modifications to consider}
% \begin{itemize}
% \item Use |\obeylines| within inline commands, so as to catch runaway arguments before end of document?
% \item Command-line view, as in Sage\TeX?
% \item Built-in support for background colors for blocks and verbatim, via |mdframed|?
% \item Consider support for executing other languages.  It might be nice to support a few additional languages at a basic level by version 1.0.  Languages currently under consideration:  Perl, MATLAB, Mathematica, Lua, Sage, R.  But note that there are ways to interface with many or perhaps all of these from within Python.  Also, consider general command line-access, similar to |\write18|.  The |bashful| package can do some nice command-line things.  But it would probably require some real finesse to get that kind of |bash| access cross-platform.  Probably could figure out a way to access Cygwin's bash or GnuWin32 or MSYS.
% \item Support for executing external scripts, not just internal code?  It would be nice to be able to typeset an external file, as well as execute it by passing command-line arguments and then pull in its output.
% \item Methods for dealing with multiple versions of Python installed.
% \item Merge |fancyvrb| and Pygments code using |\let| and bools?  More unified codebase for simpler future modifications.
% \item Is there any reason that saved printed content should be allowed to be brought in before the code that caused it has been typeset?  Are there any cases in which the output should be typeset \textbf{before} the code that created it?  That would require some type of external file for bringing in saved definitions.  Maybe there should be a |\typesetpythontex| command that parallels |\printpythontex|?
% \item Consider some type of primitive line-breaking algorithm for use with Pygments.  Could break at closest space, indent 8 spaces further than parent line (assuming 4-space indents; could auto-detect the correct size), and use \LaTeX\ counter commands to keep the line numbering from being incorrectly incremented.  Such an approach might not be hard and might have some real promise.
% \item Consider tracking script exit codes.
% \item Consider allowing names of files into which scripts are saved to be specified.  This could allow \pytex\ to be used for literate programming, general code documentation, etc.  Also, it could allow writing a document that describes code and also produces the code files, for user modification (see the |bashful| package for the general idea).  Doing something like this would probably require a new, slightly modified interface to preexisting macros.
% \item Consider methods of taking \pytex\ documents and removing their dependence on |pythontex.sty|.  Something that could convert a \pytex\ document into a document that would be more readily acceptable by a publisher.  Sage\TeX\ has something like this.
% \end{itemize}
%
%
% \subsection{Roadmap}
% \label{sec:future:roadmap}
%
% Under development.  For now, see the To Do list.
%
%
% 
%
% \PrintChanges
%
% \StopEventually{\PrintIndex}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
%
% This section describes the technical implementation of the package.  Unless you wish to understand all the fine details or need to use the package in extremely sophisticated ways, you should not need to read it.
%
% The prefix |pytx@| is used for all \pytex\ macros, to prevent conflict with other packages.  Macros that simply store text or a value for later retrieval are given names completely in lower case.  For example, |\pytx@packagename| stores the name of the package, |PythonTeX|.  Macros that actually perform some operation in contrast to simple storage are named using CamelCase, with the first letter after the prefix being capitalized.  For example, |\pytx@CheckCounter| checks to see if a counter exists, and if not, creates it.  Thus, macros are divided into two categories based on their function, and named accordingly.
%
% \subsection{Package opening}
% We begin according to custom by specifying the version of \LaTeX\ that we require and stating the package that we are providing.  We also store the name of the package in a macro for later use in warnings and error messages.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[1999/12/01]
\ProvidesPackage{pythontex}[2012/05/09 v0.9beta2]
\newcommand{\pytx@packagename}{PythonTeX}
%    \end{macrocode}
%
% \subsection{Required packages}
% A number of packages are required.  |fancyvrb| is used to typeset all code that is not inline, and its internals are used to format inline code as well.  |etex| provides extra registers, to avoid the (probably unlikely) possibility that the many counters required by \pytex\ will exhaust the supply. |etoolbox| is used for string comparison and boolean flags.  |xstring| provides the |\tokenize| macro.  |pgfopts| is used to process package options, via the |pgfkeys| package.  |makecmds| gives us |\provideenvironment|.  |newfloat| allows the creation of a floating environment for code listings.  |xcolor| is needed for syntax highlighting with Pygments (technically, we could get by with |color|, but the added functionality of |xcolor| can be convenient for other uses).
%    \begin{macrocode}
\RequirePackage{fancyvrb}
\RequirePackage{etex}
\RequirePackage{etoolbox}
\RequirePackage{xstring}
\RequirePackage{pgfopts}
\RequirePackage{makecmds}
\RequirePackage{newfloat}
\RequirePackage{xcolor}
%    \end{macrocode}
%
% We will only use |makecmds| once, so we go ahead and do so.  \pytex\ uses labels to bring in some content.  These should be ignored by the |hyperref| package if it is loaded, so all references to these labels are wrapped in the |NoHyper| environment.  But this presents a problem if |hyperref| is not loaded, because then |NoHyper| doens't exist.  So we create a dummy |NoHyper| environment, that is created only if |hyperref| isn't loaded.
%    \begin{macrocode}
\AtBeginDocument{\provideenvironment{NoHyper}{}{}}
%    \end{macrocode}
%
% \subsection{Package options}
% We now proceed to define package options, using the |pgfopts| package that provides a package-level interface to |pgfkeys|.  All keys for package-level options are placed in the key tree under the path |/PYTX/pkgopt/|, to prevent conflicts with any other packages that may be using |pgfkeys|.
%
% \subsubsection{Autoprint}
% The |autoprint| option determines whether content printed within a code command or environment is automatically included at the location of the command or environment.  This option is boolean, and hence stored in a bool.  If the option is not used, |autoprint| is turned on by default.  If the option is used, but without a setting (|\usepackage[autoprint]{pythontex}|), it is true by default.  We use the key handler \meta{key}|/.is choice| to ensure that only true/false values are allowed.  The code for the true branch is redundant with the prior setting of the bool to true, but is included for symmetry.
%    \begin{macrocode}
\newbool{pytx@opt@autoprint}
\booltrue{pytx@opt@autoprint}
\pgfkeys{/PYTX/pkgopt/autoprint/.default=true}
\pgfkeys{/PYTX/pkgopt/autoprint/.is choice}
\pgfkeys{/PYTX/pkgopt/autoprint/true/.code=\booltrue{pytx@opt@autoprint}}
\pgfkeys{/PYTX/pkgopt/autoprint/false/.code=\boolfalse{pytx@opt@autoprint}}
%    \end{macrocode}
%
% \subsubsection{Fix math spacing}
% The math commands |\left| and |\right| introduce extra, undesirable spacing in mathematical formulae.  For example, compare the results of |$\sin(x)$| and |$\sin\left(x\right)$|:  $\sin(x)$ and $\sin\left(x\right)$.  The |fixlr| option fixes this, using a solution proposed by Mateus Ara\'{u}jo, Philipp Stephani, and Heiko Oberdiek.\footnote{ \url{http://tex.stackexchange.com/questions/2607/spacing-around-left-and-right}}
%
% The option is boolean, automatically turned on unless otherwise set, and coded as the |autoprint| option.
%    \begin{macrocode}
\newbool{pytx@opt@fixlr}
\booltrue{pytx@opt@fixlr}
\pgfkeys{/PYTX/pkgopt/fixlr/.default=true}
\pgfkeys{/PYTX/pkgopt/fixlr/.is choice}
\pgfkeys{/PYTX/pkgopt/fixlr/true/.code=\booltrue{pytx@opt@fixlr}}
\pgfkeys{/PYTX/pkgopt/fixlr/false/.code=\boolfalse{pytx@opt@fixlr}}
%    \end{macrocode}
%
% \subsubsection{Keep temporary files}
% By default, \pytex\ tries to be very tidy.  It creates many temporary files, but deletes all that are not required to compile the document, keeping the overall file count very low.  At times, particularly during debugging, it may be useful to keep these temporary files, so that code, errors, and output may be examined more directly.  The |keeptemps| option makes this possible.
%
% |keeptemps| is set to |none| by default.  The key handler \meta{key}|/.is choice| is used to restrict the values to |all| (all temp files saved), |code| (only code temp files saved), and |none|.  The default value is |all|.  Since |keeptemps| can take non-boolean values, its state is stored in a regular macro rather than a bool.
%    \begin{macrocode}
\def\pytx@opt@keeptemps{none}
\pgfkeys{/PYTX/pkgopt/keeptemps/.default=all}
\pgfkeys{/PYTX/pkgopt/keeptemps/.is choice}
\pgfkeys{/PYTX/pkgopt/keeptemps/all/.code=\def\pytx@opt@keeptemps{all}}
\pgfkeys{/PYTX/pkgopt/keeptemps/code/.code=\def\pytx@opt@keeptemps{code}}
\pgfkeys{/PYTX/pkgopt/keeptemps/none/.code=\def\pytx@opt@keeptemps{none}}
%    \end{macrocode}
%
% \subsubsection{Pygments}
% Pygments is a generic syntax highlighter written in Python.  By default, \pytex\ uses |fancyvrb| to typeset code.  This provides nice formatting and font options, but no syntax highlighting.  The |pygments| option determines whether Pygments or |fancyvrb| is used to typeset code.  Command and environment families follow the |pygments| option by default, but they may be set to override it and always use Pygments or use |fancyvrb| regardless of the package-level option.
%
% Since \pytex\ sends code to Python anyway, having Pygments process the code is only a small additional step and in many cases takes little if any extra time to execute.\footnote{Pygments code highlighting is executed as a separate process by |pythontex.py|, so it runs in parallel on a multicore system.  Pygments usage is optimized by saving highlighted code and only reprocessing it when changed.}
%
% The |pygments| option is stored in a bool.  If no value is supplied, or the value is |true|, all code is typeset with Pygments, unless an override has been set.  If the value is |false|, no code is typeset with Pygments, unless again an override has been set.
%
% Pygments has been used previously to highlight code for \LaTeX, most notably in the |minted| package.
%    \begin{macrocode}  
\newbool{pytx@opt@pygments}
\pgfkeys{/PYTX/pkgopt/pygments/.default=true}
\pgfkeys{/PYTX/pkgopt/pygments/.is choice}
\pgfkeys{/PYTX/pkgopt/pygments/true/.code=\booltrue{pytx@opt@pygments}}
\pgfkeys{/PYTX/pkgopt/pygments/false/.code=\boolfalse{pytx@opt@pygments}}
%    \end{macrocode}
%
% We also need a way to specify Pygments options at the package level.  This is accomplished via the |pygopt| option:  |pygopt|=\{\meta{options}\}.  Note that the options must be enclosed in curly braces since they contain equals signs and thus must be distinguishable from package options.
%
% Currently, three options may be passed in this manner:  |style=|\meta{style~name}, which sets the formatting style; |texcomments|, which allows \LaTeX\ in code comments to be rendered; and |mathescape|, which allows \LaTeX\ math mode (|$...$|) in comments.  The |texcomments| and |mathescape| options may be used with an argument (for example, |texcomments=|\meta{True/False}); if an argument is not supplied, |True| is assumed.  As an example of |pygopt| usage, consider the following:   |pygopt={style=colorful, texcomments=True, mathescape=False}|.
%
% While the package-level |pygments| option may be overridden by individual commands and environments (though it is not by default), the package-level Pygments options cannot be overridden by individual commands and environments.
%
% Pygments options are stored in the |\pytx@pygopt| macro.
%
%    \begin{macrocode}  
\pgfkeys{/PYTX/pkgopt/pygopt/.code=\edef\pytx@pygopt{#1}}
%    \end{macrocode}
%
% By default, code highlighted by Pygments is brought back via |fancyvrb|'s |SaveVerbatim| macro, which saves verbatim content into a macro and then allows it to be restored.  This makes it possible for all Pygments content to be brought back in a single file, keeping the total file count low (which is a major priority for \pytex!).  This approach does have a disadvantage, though, because |SaveVerbatim| slows down as the length of saved code increases.\footnote{The macro in which code is saved is created by grabbing the code one line at a time, and for each line redefining the macro to be its old value with the additional line tacked on.  This is rather inefficient, but apparently there isn't a good alternative.}  To deal with this issue, we create the |pygextfile| option, which is stored in |\pytx@pygextfile|.  This option takes an integer, |pygextfile|=\meta{integer}.  All code typeset by Pygments that is more than \meta{integer} lines long will be saved to its own external file and inputted from there, rather than saved and restored via |fancyvrb|.  This provides a workaround for |fancyvrb| should its speed ever become a hindrance for large blocks of code.
%
% A default value of 25 is set.  There is nothing special about 25; it is just a relatively reasonably cutoff
%
%    \begin{macrocode}
\pgfkeys{/PYTX/pkgopt/pygextfile/.default=25}  
\pgfkeys{/PYTX/pkgopt/pygextfile/.code=\edef\pytx@pygextfile{#1}}
%    \end{macrocode}
%
% \subsubsection{Process options}
% Now we process the package options.  We also create a |pytx@pygmentsopt| macro with no value if one does not already exist (that is, if the |pygopt| option is unused).
%    \begin{macrocode}
\ProcessPgfPackageOptions{/PYTX/pkgopt}
\ifcsname pytx@pygmentsopt\endcsname\else\edef\pytx@pygopt{}\fi
%    \end{macrocode}
%
% The |fixlr| option only affects one thing, so we go ahead and take care of that.
%    \begin{macrocode}
\ifbool{pytx@opt@fixlr}{
    \let\originalleft\left
    \let\originalright\right
    \renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}%
    \renewcommand{\right}{\aftergroup\egroup\originalright}%
}{}%
%    \end{macrocode}
%
% \subsection{Utility macros and input/output setup}
% Once options are processed, we proceed to define a number of utility macros and setup the file input/output that is required by \pytex.
%
% \subsubsection{Automatic counter creation}
% 
% \begin{macro}{\pytx@CheckCounter}
% We will be using counters to give each command/environment a unique identifier, as well as to manage line numbering of code when desired.  We don't know the names of the counters ahead of time (this is actually determined by the user's naming of code sessions), so we need a macro that checks whether a counter exists, and if not, creates it.
%    \begin{macrocode}
\def\pytx@CheckCounter#1{%
    \@ifundefined{c@#1}{\newcounter{#1}}{}%
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Detection of current style}
% \begin{macro}{\pytx@style}\begin{macro}{\pytx@SetStyle}
% It would be nice if when our code is executed, we could know if it came from a text context or a math context.  If it is from a math context, it would be nice to know more about the context so that we know, for example, how to typeset fractions (1/2 vs.\ $\frac{1}{2}$ vs.\ $\displaystyle\frac{1}{2}$).  The |\pytx@SetStyle| macro does this detection for us, and saves the result in |\pytx@style|.  The macro is conditionally defined at the beginning of the document, depending on whether the |amsmath| package has been loaded.  If |amsmath| is loaded, then the macro is defined to detect the |align| and |gather| environments.  Note that we can detect the difference between inline (|$...$| or |\(...\)|) and equations (|$$...$$| or |\[...\]| or |equation|), but not the difference between standard inline and display-style inline (|$...$| vs.\ |$\displaystyle...$|).  In most cases, this should be sufficient.
%    \begin{macrocode}
\AtBeginDocument{%
    \@ifpackageloaded{amsmath}%
        {\def\pytx@SetStyle{%
            \edef\pytx@style{%
                \ifmmode
                    \ifinalign@ align%
                    \else\ifingather@ gather%
                        \else\ifinner text%
                            \else display%
                            \fi
                        \fi
                    \fi
                \else nonmath%
                \fi
            }%
        }}%
        {\def\pytx@SetStyle{%
            \edef\pytx@style{%
                \ifmmode
                    \ifinner text%
                    \else display%
                    \fi
                \else nonmath%
                \fi
            }%
       }}%
}%
%    \end{macrocode}
% \end{macro}\end{macro}
%
% \subsubsection{Code groups}
% By default, \pytex\ executes code based on sessions.  All of the code entered within a command and environment family is divided based on sessions, and each session is saved to an external file and executed.  If you have a calculation that will take a while, you can simply give it its own named session, and then the code will only be executed when there is a change within that session.
%
% While this approach is appropriate for many scenarios, it is sometimes inefficient.  For example, suppose you are writing a document with multiple chapters, and each chapter needs its own session.  You could manually do this, but that would involve a lot of commands like |\py[chapter x]{some code}|, which means lots of extra typing, not to mention the potential issues if you rename or renumber your chapters.  So we need a way to subdivide or restart sessions, based on context such as chapter, section, or subsection.
%
% Groups provide a solution to this problem.  Each session is subdivided based on groups behind the scenes.  By default, this changes nothing, because each session is put into a single default group.  But the user can redefine groups based on chapter, section, and other counters, so that sessions are automatically subdivided accordingly.  Note that there is no continuity between sessions thus subdivided.  For example, if you set groups to change between chapters, there will be no continuity between the code of those chapters, even if all the code is within the same named session.  If you require continuity, the groups approach may not be appropriate, though you could consider saving results at the end of one chapter and loading them at the beginning of the next.
% \begin{macro}{\pytx@group}\begin{macro}{\restartpythontexsession}
%
% 
%
% We begin by creating the |\restartpythontexsession| group macro, which allows the user to define groups via |\pytx@group|.  Note that groups should be defined so that they will only contain characters that are valid in file names, because groups are used in naming temporary files.  It is also a good idea to avoid using periods, since \LaTeX\ input of file names containing multiple periods can sometime be tricky.  For best results, use A-Z, a-z, 0-9, and the hyphen and underscore characters to define groups.  For example, |\restartpythontexsession{\arabic{chapter}-\arabic{section}}| could be a good approach.
%    \begin{macrocode}
\newcommand{\restartpythontexsession}[1]{\def\pytx@group{#1}}
%    \end{macrocode}
% \end{macro}\end{macro}
% For the sake of consistency, we only allow group behaviour to be set in the preamble.  And if the group is not set by the user, then we use a single default group for each session.
%    \begin{macrocode}
\@onlypreamble\restartpythontexsession
\AtBeginDocument{
    \@ifundefined{pytx@group}{\def\pytx@group{default}}{}%
}%
%    \end{macrocode}
% 
% \subsubsection{File input and output}
%
% \begin{macro}{\pytx@jobname}
% We will need to create directories and files for \pytex\ output, and some of these will need to be named using |\jobname|.  This presents a problem.  Ideally, the user will choose a job name that does not contain spaces.  But if the job name does contain spaces, then we may have problems bringing in content from a directory or file that is named based on the job, due to the space characters.  So we need a ``sanitized'' version of |\jobname|.  We replace spaces with hyphens.  We replace double quotes |"| with nothing.  Double quotes are placed around job names containing spaces by \TeX\ Live, and thus may be the first and last characters of |\jobname|.  Since we are replacing any spaces with hyphens, quote delimiting is no longer needed, and in any case, some operating systems (Windows) balk at creating directories or files with names containing double quotes.  We also replace asterisks with hyphens, since MiK\TeX\ (at least v.\ 2.9) apparently replaces spaces with asterisks in |\jobname|,\footnote{\href{http://tex.stackexchange.com/questions/14949/why-does-jobname-give-s-instead-of-spaces-and-how-do-i-fix-this}{http://tex.stackexchange.com/questions/14949/why-does-jobname-give-s-instead-of-spaces-and-how-do-i-fix-this}} and some operating systems will not be happy with names containing asterisks.
%
% This approach to ``sanitizing'' |\jobname| is not foolproof.  If there are ever two files in a directory that both use \pytex, and if their names only differ by these substitutions for spaces, quotes, and asterisks, then the output of the two files will collide, and the user may receive some interesting errors.  We believe that it is better to graciously handle the possibility of space characters at the expense of nearly identical file names, since nearly identical file names are arguably a much worse practice than file names containing spaces, and since such nearly identical file names should be much rarer.  At the same time, in rare cases a collision might occur, and in even rarer cases it might go unnoticed.\footnote{In general, a collision would produce errors, and the user would thereby become aware of the collision.  The dangerous case is when the two files with similar names use exactly the same \pytex\ commands, the same number of times, so that the naming of the output is identical.  In that case, no errors would be issued.}  To prevent such issues, |pythontex.py| checks for this and issues a warning if a potential collision is detected.
%    \begin{macrocode}
\StrSubstitute{\jobname}{ }{-}[\pytx@jobname]
\StrSubstitute{\pytx@jobname}{"}{}[\pytx@jobname]
\StrSubstitute{\pytx@jobname}{*}{-}[\pytx@jobname]
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pytx@outputdir}\begin{macro}{\setpythontexoutputdir}
% To keep things tidy, all \pytex\ files are stored in a directory that is created in the same directory as the document.  By default, this directory is called |pythontex-files-|\meta{sanitized~jobname}, but we want to provide the user with the option to customize this.  For example, when \meta{sanitized~jobname} is very long, it might be convenient to use |pythontex-files-|\meta{abbreviated~name}.
%
% The command |\setpythontexoutputdir| stores the name of \pytex's output directory in |\pytx@outputdir|.  If the |graphicx| package is loaded, the output directory is also added to the graphics path, so that files in the output directory may be included within the main document without the necessity of specifying path information.  The command |\setpythontexoutputdir| is only allowed in the preamble, because the location of \pytex\ content must be specified before the body of the document is typeset.  If |\setpythontexoutputdir| is not invoked by the user, then we automatically invoke it at the beginning of the document to set the default directory name.
%    \begin{macrocode}
\newcommand{\setpythontexoutputdir}[1]{
    \def\pytx@outputdir{#1}
    \AtBeginDocument{\@ifpackageloaded{graphicx}{\graphicspath{{#1/}}}{}}
}%
\@onlypreamble\setpythontexoutputdir
\AtBeginDocument{%
    \@ifundefined{pytx@outputdir}%
        {\setpythontexoutputdir{pythontex-files-\pytx@jobname}}{}%
}%
%    \end{macrocode}
%
% Once we have specified the output directory, we are free to pull in content from it.  Most content from the output directory will be pulled in manually by the user (for example, via |\includegraphics|) or automatically by \pytex\ as it goes along.  But content printed by code (via labels) as well as code typeset by Pygments needs to be included conditionally, based on whether it exists and on user preference.
%
% \begin{macro}{pytx@usedpygments}
% This gets a little tricky.  We only want to pull in the Pygments content if it is actually used, since Pygments content will typically use |fancyvrb|'s |SaveVerb| environment, and this can slow down compilation when very large chunks of code are saved.  It doesn't matter if the code is actually used; saving it in a macro is what potentially slows things down.  So we create a bool to keep track of whether Pygments is ever actually used, and only bring in Pygments content if it is.\footnote{The same effect could be achieved by having |pythontex.py| delete the Pygments content whenever it is run and Pygments is not used.  But that approach is faulty in two regards.  First, it requires that |pythontex.py| be run, which is not necessarily the case if the user simply sets the package option |pygments| to |false| and the recompiles.  Second, even if it could be guaranteed that the content would be deleted, such an approach would not be optimal.  It is quite possible that the user wishes to temporarily turn off Pygments usage to speed compilation while working on other parts of the document.  In this case, deleting the Pygments content is simply deleting data that must be recreated when Pygments is turned back on.}  This bool must be set to |true| whenever a command or environment is created that makes use of Pygments (in practice, we will simply set it to true when a family is created).  Note that we cannot use the |pytx@opt@pygments| bool for this purpose, because it only tells us if the package option for Pygments usage is |true| or |false|.  Typically, this will determine if any Pygments content is used.  But it is possible for the user to create a command and environment family that overrides the package option (indeed, this may sometimes be desirable, for example, if the user wishes code in a particular language never to be highlighted).  Thus, a new bool is needed to allow detection in such nonstandard cases.
%    \begin{macrocode}
\newbool{pytx@usedpygments}
%    \end{macrocode}
% \end{macro}
%
% Now we can conditionally bring in the Pygments content.  Note that we must use the |etoolbox| macro |\AfterEndPreamble|.  This is because commands and environments are created using |\AtBeginDocument|, so that the user can change their properties in the preamble before they are created.  And since the commands and environments must be created before we know the final state of |pytx@usedpygments|, we must bring in Pygments content after that.
%    \begin{macrocode}
\AfterEndPreamble{%
    \ifbool{pytx@usedpygments}%
        {\InputIfFileExists{\pytx@outputdir/\pytx@jobname.pytxpyg}{}{}}{}
}%
%    \end{macrocode}
%
% % While we are pulling in content, we also pull in the file of labels that stores some inline printed content, if the file exists.  Since we need this file in general, and since it will not typically invole a noticeable speed penalty, we bring it in at the beginning of the document without any special conditions.
%    \begin{macrocode}
\AtBeginDocument{%
    \InputIfFileExists{\pytx@outputdir/\pytx@jobname.pytxref}{}{}
}%
%    \end{macrocode}
% \end{macro}\end{macro}
% 
% That takes care of the output directory and of part of the input.  Now we can prepare for saving code from the document to an external file.  This code is saved in the same directory as the main file, not in the \pytex\ output directory (because it does not exist until |pythontex.py| runs for the first time).  But we cannot prepare to save the code until the output directory has been specified (so that its name can be passed to |pythontex.py| via the code file).  Since the output directory is specified within |\AtBeginDocument|, what follows requires |\AtBeginDocument| as well.
%
% \begin{macro}{\pytx@codefile}
% We create a new write, named |\pytx@codefile|, to which we will save code.  All the code from the document will be written to this single file, interspersed with information specifying where in the document it came from.  \pytex\ parses this file to separate the code into individual sessions and groups.  These are then executed, and the identifying information is used to tie code output back to the original code in the document.\footnote{The choice to write all code to a single file is the result of two factors.  First, \TeX\ has a limited number of output registers available (16), so having a separate output stream for each group or session is not possible.  The |morewrites| package from Bruno Le Floch potentially removes this obstacle, but since this package is very recent (README from 2011/7/10), we will not consider using additional writes in the immediate future.  Second, one of the design goals of \pytex\ is to minimize the number of persistent files created by a run.  This keeps directories cleaner and makes file synchronization/transfer somewhat simpler.  Using one write per session or group could result in numerous code files, and these could only be cleaned up by |pythontex.py| since \LaTeX\ cannot delete files itself (well, without unrestricted |write18|).  Using a single output file for code does introduce a speed penalty since the code does not come pre-sorted by session or group, but in typical usage this should be minimal.  Adding an option for single or multiple code files may be something to reconsider at a later date.}
%     \begin{macrocode}
\AtBeginDocument{\newwrite\pytx@codefile}
%    \end{macrocode}
% \end{macro}
% 
% In the output file, information from \pytex\ must be interspersed with the code.  Some type of delimiting is needed for \pytex\ information.  All \pytex\ content is written to the file in the form |=>PYTHONTEX#|\meta{content}|#|.  When this content involves package options, the delimiter is modified to the form |=>PYTHONTEX#PARAMS#|\meta{content}|#|.  The |#| symbol is also used as a subdelimiter within \meta{content}.  The |#| symbol is convenient as a delimiter since it has a special meaning in \TeX\ and is very unlikely to be accidentally entered by the user in unexpected locations (for example, within \meta{content}).  Note that the usage of ``|=>PYTHONTEX#|'' as a beginning delimiter for \pytex\ data means that this string should \textbf{never} be written by the user at the beginning of a line, because |pythontex.py| will try to intepret it as data and will fail.
%
% \begin{macro}{\pytx@delimchar}
% We create a macro to store the delimiting character.
%    \begin{macrocode}
\edef\pytx@delimchar{\string#}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pytx@delim}
% We create a macro to store the general delimiter.
%    \begin{macrocode}
\edef\pytx@delim{=\string>PYTHONTEX\string#}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pytx@delimparam}
% And we create a second macro to store the delimiter for package parameters that are passed to Python.
%    \begin{macrocode}
\edef\pytx@delimparam{=\string>PYTHONTEX\string#PARAMS\string#}
%    \end{macrocode}
% \end{macro}
% The code file is currently empty.  At this point, at the very beginning of the file, we need to pass document parameters to Python.
%    \begin{macrocode}
\AtBeginDocument{
    \immediate\openout\pytx@codefile=\jobname.pytxcode
    \immediate\write\pytx@codefile{%
        \pytx@delimparam outputdir=\pytx@outputdir\pytx@delimchar}%
    \immediate\write\pytx@codefile{%
        \pytx@delimparam keeptemps=\pytx@opt@keeptemps\pytx@delimchar}%
    \immediate\write\pytx@codefile{%
        \pytx@delimparam pygments=%
        \ifbool{pytx@opt@pygments}{True}{False}\pytx@delimchar}%
    \immediate\write\pytx@codefile{\pytx@delimparam pygmentsoptions:%
        \string{\pytx@pygopt\string}\pytx@delimchar}%
    \ifcsname pytx@pygextfile\endcsname
        \immediate\write\pytx@codefile{%
            \pytx@delimparam pygextfile=\pytx@pygextfile \pytx@delimchar}%
    \else\fi
}%
%    \end{macrocode}
%
% \begin{macro}{\pytx@WriteCodefileInfo}
% Later, we will frequently need to write delimiting information of a fixed form to the code file.  We create a macro to simplify that process.  We also create an alternate form, for use with external files that must be inputted or read in by \pytex\ and processed.  While the standard form employs a counter that is incremented elsewhere, the version for external files substitutes a zero (0) for the counter, because each external file must be unique in name and thus numbering via a counter is redundant.\footnote{The external-file form also takes an optional argument.  This corresponds to a command-line argument that is passed to an external file during the file's execution.  Currently, executing external files, with or without arguments, is not implemented.  But this feature is under consideration, and the macro retains the optional argument for the potential future compatibility.}
%    \begin{macrocode}
\def\pytx@WriteCodefileInfo{%
    \immediate\write\pytx@codefile{\pytx@delim\pytx@type\pytx@delimchar%
        \pytx@session\pytx@delimchar\pytx@group\pytx@delimchar%
        \arabic{\pytx@counter}\pytx@delimchar\pytx@cmd\pytx@delimchar%
        \pytx@style\pytx@delimchar\the\inputlineno\pytx@delimchar}%
}%
\newcommand{\pytx@WriteCodefileInfoExt}[1][]{%
    \immediate\write\pytx@codefile{\pytx@delim\pytx@type\pytx@delimchar%
        \pytx@session\pytx@delimchar\pytx@group\pytx@delimchar%
        0\pytx@delimchar\pytx@cmd\pytx@delimchar%
        \pytx@style\pytx@delimchar\the\inputlineno\pytx@delimchar#1}%
}%
%    \end{macrocode}
% \end{macro}
%
% At the end of the document, we need to close the code file, so we go ahead and issue the commands for that.  From now on, we may simply write to the code file when necessary, and need not otherwise concern ourselves with the file.
%    \begin{macrocode}
\AtEndDocument{%
    \immediate\write\pytx@codefile{%
        \pytx@delim END\pytx@delimchar END\pytx@delimchar END\pytx@delimchar%
        END\pytx@delimchar END\pytx@delimchar END\pytx@delimchar END\pytx@delimchar}
    \immediate\closeout\pytx@codefile
}%
%    \end{macrocode}
%
% \subsubsection{Interface to \texttt{fancyvrb}}
% The |fancyvrb| package is used to typeset lines of code, and its internals are also used to format inline code snippets.  We need a way for each family of \pytex\ commands and environments to have its own independent |fancyvrb| settings.
% \begin{macro}{\pytx@fvsettings}\begin{macro}{\setpythontexfv}
% The macro |\setpythontexfv|\oarg{family}\marg{settings} takes \meta{settings} and stores them in a macro that is run through |fancyvrb|'s |\fvset| at the beginning of \pytex\ code.  If a \meta{family} is specified, the settings are stored in |\pytx@fvsettings@|\meta{family}, and the settings only apply to typeset code belonging to that family.  If no optional argument is given, then the settings are stored in |\pytx@fvsettings|, and the settings apply to all typeset code.
%
% In the current implementation, |\setpythontexfv| and |\fvset| differ because the former is not persistent in the same sense as the latter.  If we use |\fvset| to set one property, and then use it later to set another property, the setting for the original property is persistant.  It remains until another |\fvset| command is issued to change it.  In contrast, every time |\setpythontexfv| is used, it clears all prior settings and only the current settings actually apply.  This is because |\fvset| stores the state of each setting in its own macro, while |\setpythontexfv| simply stores a string of settings that are passed to |\fvset| at the appropriate times.  For typical use scenarios, this distinction shouldn't be important---usually, we will want to set the behavior of |fancyvrb| for all \pytex\ content, or for a family of \pytex\ content, and leave those settings constant throughout the document.  Furthermore, environments that typeset code take |fancyvrb| commands as their second optional argument, so there is already a mechanism in place for changing the settings for a single environment.  However, if we ever want to change the typesetting of code for only a small portion of a document (larger than a single environment), this persistence distinction does become important.\footnote{An argument could be made for implementing full persistence within \pytex.  Such an approach would have advantages when persistance is important and this should be considered for a future release.  At the same time, properly implementing full persistence is tricky, because of inheritance issues between \pytex-wide and family-specific settings (this is probably a job for |pgfkeys|).  Full persistence would likely require a large number of macros and conditionals.  At least from the perspective of keeping the code clean and concise, the current approach is superior, and probably introduces minor annoyances at worst.}
%    \begin{macrocode}
\newcommand{\setpythontexfv}[2][]{%
    \ifstrempty{#1}%
        {\gdef\pytx@fvsettings{#2}}%
        {\expandafter\gdef\csname pytx@fvsettings@#1\endcsname{#2}}%
}%
%    \end{macrocode}
% 
% Now that we have a mechanism for applying global settings to typeset \pytex\ code, we go ahead and set a default tab size for all environments.  If |\setpythontexfv| is ever invoked, this setting will be overwritten, so that must be kept in mind.
%     \begin{macrocode}
\setpythontexfv{tabsize=4}
%    \end{macrocode}
% \end{macro}\end{macro}
%
% \begin{macro}{\pytx@FVSet}
% Once the |fancyvrb| settings for \pytex\ are stored in macros, we need a way to actually invoke them.  |\pytx@FVSet| applies family-specific settings first, then \pytex-wide settings second, so that \pytex-wide settings have precedence and will override family-specific settings.  Note that by using |\fvset|, we are overwriting |fancyvrb|'s settings.  Thus, to keep the settings local to the \pytex\ code, |\pytx@FVSet| must always be used within a |\begingroup ... \endgroup| block.
%    \begin{macrocode}
\def\pytx@FVSet{%
    \expandafter\let\expandafter\pytx@fvsettings@family
        \csname pytx@fvsettings@\pytx@type\endcsname
    \ifdefstring{\pytx@fvsettings@family}{}%
        {}%
        {\expandafter\fvset\expandafter{\pytx@fvsettings@family}}%
    \ifdefstring{\pytx@fvsettings}{}%
        {}%
        {\expandafter\fvset\expandafter{\pytx@fvsettings}}%
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Access to printed content (stdout)}
% The |autoprint| package option automatically pulls in printed content from |code| commands and environments.  But this does not cover all possible use cases, because we could have print functions (or statements, prior to Python 3) in |block| commands and environments as well.  Furthermore, sometimes we may print content, but then desire to bring it back into the document multiple times, without duplicating the code that creates the content.  Here, we create a number of macros that allow access to printed content.  All macros are created in two identical forms, one based on the name |print| and one based on the name |stdout|.  Which macros are used depends on user preference.  The macros based on |stdout| provide symmetry with the |stderr| access that will be added in the very near future.\pytxtodo(Edit for stderr)
%
% \begin{macro}{\pytx@outfile}
% We begin by defining a macro to hold the name of the last file to which content was printed (assuming that any content actually was printed).  The name of this file is updated by most commands and environments so that it stays current.\footnote{It is only updated by those commands and environments that interact with |pythontex.py| and thus increment a type-session-group counter so that they can be distinguished.  |verb| commands and environments that use |fancyvrb| for typesetting do not interact with |pythontex.py|, do not increment a counter, and do not update the outfile.}  It is important, however, to initially set the name empty for error-checking purposes.
%    \begin{macrocode}
\def\pytx@outfile{}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pytx@FetchOutfile}
% Now we create a generic macro for bringing in the outfile.  This macro can bring the content in verbatim form, applying |fancyvrb| options if present.  Usage:  |\pytx@FetchOutfile|\oarg{verbatim~options}\oarg{fancyvrb~options}\marg{file~path}.\pytxtodo{Error handling for invalid options?}
%    \begin{macrocode}
\def\pytx@FetchOutfile[#1][#2]#3{%
    \IfFileExists{\pytx@outputdir/#3}{%
        \ifstrequal{#1}{}{\input{\pytx@outputdir/#3}}{}%
        \ifstrequal{#1}{verb}{\VerbatimInput[#2]{\pytx@outputdir/#3}}{}%
        \ifstrequal{#1}{inlineverb}{\BVerbatimInput[#2]{\pytx@outputdir/#3}}{}%
    }%
    {\textbf{??~\pytx@packagename~??}%
        \PackageWarning{\pytx@packagename}{Non-existent printed content}}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\printpythontex}\begin{macro}{\stdoutpythontex}
% We define a macro that pulls in the content of the most recent |\pytx@outfile|, accepting verbatim settings and also |fancyvrb| settings if they are given.
%    \begin{macrocode}
\def\printpythontex{%
    \@ifnextchar[{\pytx@Print}{\pytx@Print[]}%
}%
\def\pytx@Print[#1]{%
    \@ifnextchar[{\pytx@Print@i[#1]}{\pytx@Print@i[#1][]}%
}%
\def\pytx@Print@i[#1][#2]{%
    \pytx@FetchOutfile[#1][#2]{\pytx@outfile}%
}%
\let\stdoutpythontex\printpythontex
%    \end{macrocode}
% \end{macro}\end{macro}
%
% \begin{macro}{\saveprintpythontex}
% Sometimes, we may wish to use printed content at multiple locations in a document.  Because |\pytx@outfile| is changed by every command and environment that could print, the printed content that |\printpythontex| tries to access is constantly changing.  Thus, |\printpythontex| is of use only immediately after content has actually been printed, before any additional \pytex\ commands or environments change the definition of |\pytx@oufile|.  To get around this, we create |\saveprintpythontex|\marg{name}.  This macro saves the current name of |\pytx@outfile| so that it is associated with \meta{name} and thus can be retrieved later, after |\pytx@outfile| has been redefined.
%    \begin{macrocode}
\def\saveprintpythontex#1{%
    \ifcsname pytx@SVOUT@#1\endcsname
        \PackageError{\pytx@packagename}%
            {Attempt to save content using an already-defined name}%
            {Use a name that is not already defined}%
    \else
        \expandafter\edef\csname pytx@SVOUT@#1\endcsname{\pytx@outfile}%
    \fi
}%
\let\savestdoutpythontex\saveprintpythontex
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\useprintpythontex}
% Now that we have saved the current |\pytx@outfile| under a new, user-chosen name, we need a way to retrieve the content of that file later, using the name.
%    \begin{macrocode}
\def\useprintpythontex{%
    \@ifnextchar[{\pytx@UsePrint}{\pytx@UsePrint[]}%
}%
\def\pytx@UsePrint[#1]{%
    \@ifnextchar[{\pytx@UsePrint@i[#1]}{\pytx@UsePrint@i[#1][]}%
}%
\def\pytx@UsePrint@i[#1][#2]#3{%
    \ifcsname pytx@SVOUT@#3\endcsname
        \pytx@FetchOutfile[#1][#2]{\csname pytx@SVOUT@#3\endcsname}%
    \else
        \textbf{??~\pytx@packagename~??}%
        \PackageWarning{\pytx@packagename}{Non-existent saved printed content}%
    \fi
}%
\let\usestdoutpythontex\useprintpythontex
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Inline commands}
% We are now ready to define the inline \pytex\ commands that are used to typeset and run code.  Creating these commands involves three steps:  (1) defining some inline-specific utility macros; (2) defining the common core of the commands; and (3) creating constructors that actually create inline commands based on a specified base name.
% \subsubsection{Inline utility macros}
% Inline commands can do one or both of two things:  they can save code (allowing it to be executed or otherwise processed) or they can typeset (show) code, or both.  We create a |bool| for each possibility.
%    \begin{macrocode}
\newbool{pytx@inline@save}
\newbool{pytx@inline@show}
%    \end{macrocode}
%
% \begin{macro}{\pytx@spacecattwelve}
% The inline macros will sometimes need to check if a character is a space character with category code 12.  We create such a space character and store it in |\pytx@spacecattwelve| to simplify such comparisons.  Are there other ways in which this could be handled?  Almost certainly.  If you have the option to have the twelfth extra-planetary feline, should you take it?  Absolutely.
%    \begin{macrocode}
\begingroup
\catcode`\ =12
\xdef\pytx@spacecattwelve{ }%
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pytx@Retokenize}\begin{macro}{\pytx@retoked}
% We will sometimes capture a string of characters, and later need to reassign their category codes so that space characters are active and all other characters have text (as opposed to various command) category codes.  The |\pytx@Retokenize| command does this for us, internally using the |\tokenize| macro from the |xstring| package.  The retokenized results are available after the macro is used in |\pytx@retoked|.
%    \begin{macrocode}
\def\pytx@Retokenize#1{%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\ =\active
    \tokenize{\pytx@retoked}{\detokenize{#1}}%
    \endgroup
}%
%    \end{macrocode}
% \end{macro}\end{macro}
%
%
% \begin{macro}{\pytx@FormatInline}
% Inline text must be formatted based on a number of factors.  The |\pytx@FVSet| brings in \pytex-wide and family-specific |fancyvrb| settings.  Most of the remainder of the commands are from |fancyvrb|'s |\FV@FormattingPrep|, and take care of various formatting matters, including spacing, font, whether space characters are shown, and any user-defined formatting.  Finally, we create an |\hbox| and invoke |\FancyVerbFormatLine| to maintain parallelism with |BVerbatim|, which is used for inline content highlighted with Pygments.  |\FancyVerbFormatLine| may be redefined to alter the typeset code, for example, by putting it in a colorbox via |\renewcommand{\FancyVerbFormatLine}[1]{\colorbox{green}{#1}}|.\footnote{Currently, |\textbackslash FancyVerbFormatLine| is global, as in |fancyvrb|.  Allowing a family-specific variant should be considered in the future.  In most cases, the |fancyvrb| option |formatcom|, combined with external formatting from packages like |mdframed|, should provide all formatting desired.  But something family-specific could occasionally prove useful.}
%    \begin{macrocode}
\def\pytx@FormatInline#1{%
    \begingroup
    \pytx@FVSet
    \frenchspacing\FV@SetupFont\FV@DefineWhiteSpace\FancyVerbDefineActive
    \FancyVerbFormatCom
    \hbox{\FancyVerbFormatLine{#1}}%
    \endgroup
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Inline core macros}
% All inline commands use the same core of inline macros.  They all invoke the |\pytx@Inline| macro, and this then branches through a number of additional macros depending on the details of the command and the usage context.  The use of a single set of macros for inline commands introduces a very slight speed penalty in the form of a few bool evaluations.  It brings the great advantage of a much simpler and easier to maintain code base.
%
% |\pytx@Inline|, and the macros it calls, perform the following series of operations.
% \begin{itemize}
% \item If there is an optional argument, capture it.  Otherwise, set the optional argument to the string ``|default|''.  The optional argument is the session name of the command.
% \item Determine the delimiting character(s) used for the code encompassed by the command.  Any character except for the space character and the opening curly brace |{| may be used as a delimiting character, just as for |\verb|.  The opening curly brace |{| may be used, but in this case the closing delimiting character is the closing curly brace |}|.  If paired curly braces are used as delimiters, then the code enclosed may only contain paired curly braces.
% \item Using the delimiting character(s), capture the code.  Typeset it or save it to the code file for further use.
% \end{itemize}
%
% \begin{macro}{\pytx@Inline}
% This is the gateway to all inline core macros.  It is called by all inline commands.
% Because the delimiting characters could be almost anything, we need to turn off all special category codes before we peek ahead with |\@ifnextchar| to see if an optional argument is present, since |\@ifnextchar| sets the category code of the character it examines.  But we set the opening curly brace |{| back to its standard catcode, so that matched braces can be used to capture an argument as usual.  The catcode changes are enclosed withing |\begingroup ... \endgroup| so that they may be contained.
%
% The macro |\pytx@InlineOarg| which is called at the end of |\pytx@Inline| takes an argument enclosed by square brackets.  If an optional argument is not present, then we supply one, using the string ``|default|''.
%    \begin{macrocode}
\def\pytx@Inline{%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\{=1
    \@ifnextchar[{\endgroup\pytx@InlineOarg}{\endgroup\pytx@InlineOarg[default]}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineOarg}
% This macro captures the optional argument (or the default substitute), which corresponds to the code session.  Then it determines whether the delimiters of the actual code are a matched pair of curly braces or a pair of other, identical characters, and calls the next macro accordingly.
%
% Since it is possible that the user supplied an empty optional argument, we begin by testing for this, and setting the default value if this is indeed the case.  It is also possible that the user chose a session name containing a colon.  If so, we substitute an underscore for the colon.  This is because temporary files are named based on session, and file names often cannot contain colons.
%
% Then we turn off all special catcodes and set the catcodes of the curly braces back to their default values.  This is necessary because we are about to capture the actual code, and we need all special catcodes turned off so that the code can contain any characters.  But curly braces still need to be active just in case they are being used as delimiters.  Using |\@ifnextchar| we determine whether the delimiters are curly braces.  If so, we proceed to |\pytx@InlineMargBgroup| to capture the code using curly braces as delimiters.  If not, we reset the catcodes of the braces and proceed to |\pytx@InlineMargOther|, which uses characters other than the opening curly brace as delimiters.
%
%    \begin{macrocode}
\def\pytx@InlineOarg[#1]{%
    \ifstrempty{#1}{\edef\pytx@session{default}}{\StrSubstitute{#1}{:}{_}[\pytx@session]}%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\{=1
    \catcode`\}=2
    \@ifnextchar\bgroup
        {\pytx@InlineMargBgroup}%
        {\catcode`\{=12
            \catcode`\}=12
            \pytx@InlineMargOther}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineMargBgroup}
% We are now ready to capture the actual code, using matched curly braces as delimiters, as determined through previous macros.
%
% At the very beginning, we must end the group that was left open from |\pytx@InlineOarg|, so that catcodes return to normal.
%
% Next we determine whether the code should be saved.  If so, we assemble the name of the counter corresponding to this code and ensure that this counter exists using |\pytx@CheckCounter|.  Then we definine the current |\pytx@outfile|, so that any printed content can be accessed later, outside of the command.  We write basic information about this code to the code file (the code type, session, and group; the current counter value; the command type; whether we are in math mode and if so what type; and the current line number).  Then we write the code itself to the file.  Note that even though the code may contain matched pairs of braces with special catcodes, it is still written correctly to file.
%
% Saved code needs special treatment in two cases.  If we are dealing with an inline |code| command, and if the |autoprint| package setting is on, then we need to check for printed content and input it if it exists.  If we are dealing with a plain inline command, then we will be bringing in content through a label, and we need to reference that label, using |NoHyper| so that the reference will be ignored by |hyperref| (if it is loaded).
% 
% Finally, we increment the code counter and reset the bool that governs whether code is saved, so that the bool is ready for future use.  Note that the counter is only used with saved content, because only that content is passed to Python and thus needs to be able to be uniquely identified.  This same approach is taken later with environments.  Because of this approach, it is possible to add or delete purely verbatim commands and environments without changing the counters associated with |block| and |code| commands and environments, and thus doing so doesn't require rerunning |pythontex.py|.
% 
% Next we determine whether the code is to be displayed.  If so, we retokenize it, so that curly braces no longer have special catcodes.  Note that the retokenizing process eliminates all special catcodes, except for setting space characters active so that they can either be shown or invisible.  Then we pass the retokenized code to |\pytx@FormatInline|, which sets fonts, spacing behavior, and other formatting, and actually typesets the code.  Finally, we reset the bool that governs whether code is displayed.
%    \begin{macrocode}
\def\pytx@InlineMargBgroup#1{%
    \endgroup
    \ifbool{pytx@inline@save}{%
        \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
        \pytx@CheckCounter{\pytx@counter}%
        \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
        \pytx@WriteCodefileInfo
        \immediate\write\pytx@codefile{#1}%
        \ifdefstring{\pytx@cmd}{inlinec}%
            {\ifbool{pytx@opt@autoprint}%
                {\InputIfFileExists{\pytx@outputdir/\pytx@outfile}{}{}}{}}%
            {}%
        \ifdefstring{\pytx@cmd}{inline}%
            {\begin{NoHyper}\ref{\pytx@counter @\arabic{\pytx@counter}}%
                \end{NoHyper}}%
            {}%
        \stepcounter{\pytx@counter}%
        \boolfalse{pytx@inline@save}%
    }{}%
    \ifbool{pytx@inline@show}{%
        \pytx@Retokenize{#1}%
        \pytx@FormatInline{\pytx@retoked}%
        \boolfalse{pytx@inline@show}%
    }{}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineMargOther}\begin{macro}{\pytx@InlineMargOtherGet}
% This macro plays the same role as the previous macro, except instead of capturing code delimited by matched curly braces, it captures code delimited by a pair of identical other characters.  Due to the nature of the capturing process, it must be performed in two steps.
%
% The macro captures only the next character.  This will be the delimiting character.  We must begin by ending the group that was left open by |\pytx@InlineOarg|, so that catcodes return to normal.  Next we check to see if the delimiting character is a space character.  If so, we issue an error, because that is not allowed.  If the delimiter is valid, we define a macro |\pytx@InlineMargOtherGet| that will capture all content up to the next delimiting character, save the code in the macro |\pytx@arg|, and call |\pytx@InlineMargOtherGet@i| to process the code.  Note that this macro begins with an |\endgroup|, because special catcodes must be turned off during the capturing process but need to be turned back on immediately afterward.
%
% Once the custom capturing macro has been created, we turn off special catcodes, make space characters active so that they can be either shown or invisible, and call the capturing macro.
%    \begin{macrocode}
\def\pytx@InlineMargOther#1{%
    \endgroup
    \ifstrequal{#1}{\pytx@spacecattwelve}%
        {\PackageError{\pytx@packagename}%
            {The space character cannot be used as a delimiting character}%
            {Choose another delimiting character}}%
        {\def\pytx@InlineMargOtherGet##1#1{%
            \endgroup
            \def\pytx@arg{##1}%
            \pytx@InlineMargOtherGet@i}%
    }%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\ =\active
    \pytx@InlineMargOtherGet
}%
%    \end{macrocode}
% \end{macro}\end{macro}
%
%
% \begin{macro}{\pytx@InlineMargOtherGet@i}
% This macro processes the captured code stored in |\pytx@arg|.  We determine whether it needs to be saved or typeset, and proceed accordingly.  The entire process is identical to what occurs in |\pytx@InlineMargBgroup|, except that the code does not need to be retokenized since it does not contain curly braces with special catcodes.
%    \begin{macrocode}
\def\pytx@InlineMargOtherGet@i{%
    \ifbool{pytx@inline@save}{%
        \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
        \pytx@CheckCounter{\pytx@counter}%
        \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
        \pytx@WriteCodefileInfo
        \immediate\write\pytx@codefile{\pytx@arg}%
        \ifdefstring{\pytx@cmd}{inlinec}%
            {\ifbool{pytx@opt@autoprint}%
                {\InputIfFileExists{\pytx@outputdir/\pytx@outfile}{}{}}{}}{}%
        \ifdefstring{\pytx@cmd}{inline}%
            {\begin{NoHyper}\ref{\pytx@counter @\arabic{\pytx@counter}}%
                \end{NoHyper}}{}%
        \stepcounter{\pytx@counter}%
        \boolfalse{pytx@inline@save}%
    }{}%
    \ifbool{pytx@inline@show}{%
        \pytx@FormatInline{\pytx@arg}%
        \boolfalse{pytx@inline@show}%
    }{}%
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Inline command constructors}
% With the inline core macros complete, we are ready to create constructors for different kinds of inline commands.  All of these consctructors take a string of letters and define an inline command named using that string as a base name.
%
% \begin{macro}{\pytx@MakeInlineb}
% This macro creates inline block commands, which both typeset code and save it so that it may be executed.  The base name of the command is stored in |\pytx@type|.  A string representing the kind of command is stored in |\pytx@cmd|.  Then |\pytx@SetStyle| is used to set |\pytx@style|, so that we know whether we are in a math mode and if so what type.  Bools are set so that code is both saved and shown.  Then the core inline macros are invoked through |\pytx@Inline|.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlineb}[1]{%
    \expandafter\newcommand\expandafter{\csname #1b\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inlineb}%
        \pytx@SetStyle
        \booltrue{pytx@inline@save}%
        \booltrue{pytx@inline@show}%
        \pytx@Inline
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeInlinev}
% This macro creates inline verbatim commands, which only typeset code.  |\pytx@type|, |\pytx@cmd|, and |\pytx@style| are still set, for symmetry with other commands and so that they are available if desired.  In general use they will not be needed, though.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlinev}[1]{%
    \expandafter\newcommand\expandafter{\csname #1v\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inlinev}%
        \pytx@SetStyle
        \booltrue{pytx@inline@show}%
        \pytx@Inline
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeInlinec}
% This macro creates inline code commands, which save code for execution but do not typeset it.  If the code prints content, this content is inputted automatically if the package setting |autoprint| is on.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlinec}[1]{%
    \expandafter\newcommand\expandafter{\csname #1c\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inlinec}%
        \pytx@SetStyle
        \booltrue{pytx@inline@save}%
        \pytx@Inline
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeInline}
% This macro creates plain inline commands, which save code and then bring in the result of using a print function on the code.  The result is brought back in using labels and references, thereby cutting down on the number of external files needed.
%    \begin{macrocode}
\newcommand{\pytx@MakeInline}[1]{%
    \expandafter\newcommand\expandafter{\csname #1\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inline}%
        \pytx@SetStyle
        \booltrue{pytx@inline@save}%
        \pytx@Inline
    }%
}%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Environments}
% 
% The inline commands were all created using a common core set of macros, combined with short, command-specific constructors.  In the case of environments, we do not have a common core set of macros.  Each environment is coded separately, though there are similarities among environments.  In the future, it may be worthwhile to attempt to consolidate the environment code base.  The current approach was chosen because it was relatively concise and minimized unnecessary macros.  Since the environments heavily rely on |fancyvrb|, they are more constrained than the inline commands.
%
% One of the differences between inline commands and environments is that  environments may need to typeset code with line numbers.  Each family of code needs to have its own line numbering, and this line numbering should not overwrite any line numbering that may separately be in use by |fancyvrb|.  To make this possible, we create a counter in which we can temporarily store line numbers.  When line numbers are used, |fancyvrb|'s line counter is copied into |pytx@FancyVerbLineTemp|, lines are numbered, and then |fancyvrb|'s line counter is restored from |pytx@FancyVerbLineTemp|.  This keeps |fancyvrb| and \pytex's line numbering separate, even though \pytex\ is using |fancyvrb| and its macros internally.
%    \begin{macrocode}
\newcounter{pytx@FancyVerbLineTemp}%
%    \end{macrocode}
%
% \subsubsection{Block environment constructor}
% 
% \begin{macro}{\pytx@FancyVerbGetLine}
% The block environment needs to both typeset code and save it so it can be executed.  |fancyvrb| supports typesetting, but doesn't support saving at the same time.  So we create a modified version of |fancyvrb|'s |\FancyVerbGetLine| macro which does.  This is identical to the |fancyvrb| version, except that we add a line that writes to the code file.  The material that is written is detokenized to avoid catcode issues.
%    \begin{macrocode}
\begingroup
\catcode`\^^M=\active
\gdef\pytx@FancyVerbGetLine#1^^M{%
    \@nil%
    \FV@CheckEnd{#1}%
    \ifx\@tempa\FV@EnvironName% 
        \ifx\@tempb\FV@@@CheckEnd\else\FV@BadEndError\fi%
        \let\next\FV@EndScanning%
    \else%
        \def\FV@Line{#1}%
        \def\next{\FV@PreProcessLine\FV@GetLine}%
        \immediate\write\pytx@codefile{\detokenize{#1}}%
    \fi%
    \next}%
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeBlock}
% Now we are ready to actually create block environments.  This macro takes  an environment base name \meta{name} and creates a block environment \meta{name}|block|.
%
% The block environment is a |Verbatim| environment, so we declare that with the |\VerbatimEnvironment| macro, which lets |fancyvrb| find the end of the environment correctly.  We define the type, define the command, and set the style.  Then we let the default |\FancyVerbGetLine| to our customized macro.
%
% We need to check for optional arguments, so we begin a group and use |\obeylines| to make line breaks active.  Then we check to see if the next char is an opening square bracket.  If so, there is an optional argument, so we end our group and call the |\pytx@BeginBlockEnv| macro, which will capture the argument and finish preparing for the block content.  If not, we end the group and call the same |\pytx@BeginBlockEnv| macro with a default argument.  The line breaks need to be active during this process because we don't care about content on the next line, including opening square brackets on the next line; we only care about content in the line on which the environment is declared, because only on that line should there be an optional argument.  The problem is that since we are dealing with code, it is quite possible for there to be an opening square bracket at the beginning of the next line, so we must prevent that from being misinterpreted as an optional argument.
%
% After the environment, we need to clean up several things.  Much of this relates to the |\pytx@BeginBlockEnv| macro, so you may wish to refer to that to understand the details.  The body of the environment is wrapped in a |Verbatim| environment, so we must end that.  It is also wrapped in a group, so that |fancyvrb| settings remain local; we end the group.  Then we define the name of the outfile for any printed content, so that it may be accessed by |\printpythontex| and company.  Finally, we rearrange counters.  The current code line number needs to be stored in |\pytx@linecount|, which was defined to be specific to the current type-session-group set.  The |fancyvrb| line number needs to be set back to its original value from before the environment began, so that \pytex\ content does not affect the line numbering of |fancyvrb| content.  Finally, the |\pytx@counter|, which keeps track of commands and environments within the current type-session-group set, needs to be incremented.
%
%    \begin{macrocode}
\newcommand{\pytx@MakeBlock}[1]{%
    \expandafter\newenvironment{#1block}{%
        \VerbatimEnvironment
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{block}%
        \pytx@SetStyle
        \let\FancyVerbGetLine\pytx@FancyVerbGetLine
        \begingroup
        \obeylines
        \@ifnextchar[{\endgroup\pytx@BeginBlockEnv}{\endgroup\pytx@BeginBlockEnv[default]}%
    }%
    {\end{Verbatim}\endgroup%
    \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
    \setcounter{\pytx@linecount}{\value{FancyVerbLine}}%
    \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    \stepcounter{\pytx@counter}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BeginBlockEnv}
% This macro finishes preparations to actually begin the block environment.  It captures the optional argument (or the argument supplied by default).  If this argument is empty, then it sets the value of the argument to the default value.  If not, then colons in the optional argument are replaced with underscores, and the modified argument is stored in |\pytx@session|.  Colons are replaced with underscores because session names must be suitable for file names, and colons are generally not allowed in file names.  However, we want to be able to \textit{enter} session names containing colons, since colons provide a conventient method of indicating relationships.  For example, we could have a session named plots:specialplot.
%
% Once the session is established, we are free to define the counter for the current type-session-group, and make sure it exists.  We also define the counter that will keep track of line numbers for the current type-session-group, and make sure it exists.  Then we do some counter trickery.  We don't want |fancyvrb| line counting to be affected by \pytex\ content, so we store the current line number held by |FancyVerbLine| in |pytx@FancyVerbLineTemp|; we will restore |FancyVerbLine| to this original value at the end of the environment.  Then we set |FancyVerbLine| to the appropriate line number for the current type-session-group.  This provides proper numbering continuity between different environments within the same type-session-group.
%
% Next, we write environment information to the code file, now that all the necessary information is assembled.  We begin a group, because we need to set |fancyvrb| settings to those of the current type-session-group using |\pytx@FVSet|, but we need the settings to remain local.  Once this is done, we are finally ready to start the |Verbatim| environment.  Note that the |Verbatim| environment will capture a second optional argument delimited by square brackets, if present, and apply this argument as |fancyvrb| formatting.  Thus, the environment actually takes up to two optional arguments, but if you want to use |fancyvrb| formatting, you must supply an empty (default session) or named (custom session) optional argument for the \pytex\ code.
%    \begin{macrocode}
\def\pytx@BeginBlockEnv[#1]{%
    \ifstrempty{#1}{\edef\pytx@session{default}}{\StrSubstitute{#1}{:}{_}[\pytx@session]}%
    \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
    \pytx@CheckCounter{\pytx@counter}%
    \edef\pytx@linecount{\pytx@counter @line}%
    \pytx@CheckCounter{\pytx@linecount}%
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \setcounter{FancyVerbLine}{\value{\pytx@linecount}}%
    \pytx@WriteCodefileInfo
    \begingroup\pytx@FVSet\begin{Verbatim}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Verb environment constructor}
% \begin{macro}{\pytx@MakeVerb}
% The |verb| environments only typeset code; they do not save it for execution.  Thus, we just use a standard |fancyvrb| environment with a few enhancements.
%
% As in the block environment, we declare that we are using a |Verbatim| environment, define type and command, set style, and take care of optional arguments before calling a macro to wrap things up (in this case, |\pytx@BeginVerbEnv|).  Currently, defining the type and command, and setting the style, are unnecessary because they are not used.  But they are provided to maintain parallelism with the |block| environment, and so that they are available should they ever be wanted.
%
% Ending the environment involves ending the |Verbatim| environment begun by |\pytx@BeginVerbEnv|, ending the group that kept |fancyvrb| settings local, and resetting counters.  We never define an outfile, and we don't step the counter for the current type-session-group.  This is because verb environments can't print anything and thus don't need |\printpythontex| and company, and because a counter is only needed to keep track of code that actually is passed to Python.  If we were to use a counter, that would mean that adding or removing purely verbatim content would change the counters for non-verbatim content within the same type-session-group, which would then require that |pythontex.py| be run again to fix the counter discrepencies.  That would be inefficient.
%    \begin{macrocode}
\newcommand{\pytx@MakeVerb}[1]{%
    \expandafter\newenvironment{#1verb}{%
        \VerbatimEnvironment
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{verb}%
        \pytx@SetStyle
        \begingroup
        \obeylines
        \@ifnextchar[{\endgroup\pytx@BeginVerbEnv}{\endgroup\pytx@BeginVerbEnv[default]}%
    }%
    {\end{Verbatim}\endgroup%
    \setcounter{\pytx@linecount}{\value{FancyVerbLine}}%
    \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BeginVerbEnv}
% This macro captures the optional argument of the environment (or the default argument that is otherwise supplied).  If the argument is empty, it assignes a default value; otherwise, it substitutes underscores for colons in the argument.  The argument is assigned to |\pytx@session|.  A line counter is created, and its existence is checked.  (Again, we don't create the standard type-session-group counter because it isn't needed and would make things less efficient.)  We do the standard line counter trickery.  Then we begin a group to keep |fancyvrb| settings local, invoke the settings via |\pytx@FVSet|, and begin the |Verbatim| environment.
%    \begin{macrocode}
\def\pytx@BeginVerbEnv[#1]{%
    \ifstrempty{#1}{\edef\pytx@session{default}}{\StrSubstitute{#1}{:}{_}[\pytx@session]}%
    \edef\pytx@linecount{pytx@\pytx@type @\pytx@session @\pytx@group @line}%
    \pytx@CheckCounter{\pytx@linecount}%
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \setcounter{FancyVerbLine}{\value{\pytx@linecount}}%
    \begingroup\pytx@FVSet\begin{Verbatim}%
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Code environment constructor}
% The |code| environment merely saves code to the code file; nothing is typeset.  To accomplish this, we use a slightly modified version of |fancyvrb|'s |VerbatimOut|.  
% \begin{macro}{\pytx@WriteDetok}
% We can use |fancyvrb| to capture the code, but we will need a way to write the code in detokenized form.  This is necessary so that \TeX\ doesn't try to process the code as it is written, which would generally be disastrous.
%    \begin{macrocode}
\def\pytx@WriteDetok#1{%
    \immediate\write\pytx@codefile{\detokenize{#1}}}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@FVB@VerbatimOut}
% We need a custom version of the macro that begins |VerbatimOut|.  We don't need |fancyvrb|'s key values, and due to our use of |\detokenize| to write content, we don't need its space and tab treatment either.  We do need |fancyvrb| to write to our code file, not the file to which it would write by default.  And we don't need to open any files, because the code file is already open.  These last two are the only important differences between our version and the original |fancyvrb| version.  Since we don't need to write to a user-specified file, we don't require the mandatory argument of the original macro.
%    \begin{macrocode}
\def\pytx@FVB@VerbatimOut{%
    \@bsphack
    \begingroup
    \let\FV@ProcessLine\pytx@WriteDetok
    \let\FV@FontScanPrep\relax
    \let\@noligs\relax
    \FV@Scan}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@FVE@VerbatimOut}
% Similarly, we need a custom version of the macro that ends |VerbatimOut|.  We don't want to close the file to which we are saving content.
%    \begin{macrocode}
\def\pytx@FVE@VerbatimOut{\endgroup\@esphack}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeCode}
% Now that the helper macros for the |code| environment have been defined, we are ready to create the macro that makes |code| environments.  Everything at the beginning of the environment is exactly as it is in the |block| and |verb| environments, except that we let the beginning and ending |VerbatimOut| macros to our own custom versions, and call the |\pytx@BeginCodeEnv| macro to capture an optional argument.
%
% After the environment, we need to close the |VerbatimOut| environment begun by |\pytx@BeginCodeEnv|.  We don't need to end a group, because no group was necessary for the environment contents since there were no |fancyvrb| formatting settings that needed to remain local.  We define the outfile, and bring in any printed content if the |autoprint| setting is on.  We must still perform some |FancyVerbLine| trickery to prevent the |fancyvrb| line counter from being affected by \textbf{writing} content!  Finally, we step the counter.
%    \begin{macrocode}
\newcommand{\pytx@MakeCode}[1]{%
    \expandafter\newenvironment{#1code}{%
        \VerbatimEnvironment
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{code}%
        \pytx@SetStyle
        \let\FVB@VerbatimOut\pytx@FVB@VerbatimOut
        \let\FVE@VerbatimOut\pytx@FVE@VerbatimOut
        \begingroup
        \obeylines
        \@ifnextchar[{\endgroup\pytx@BeginCodeEnv}{\endgroup\pytx@BeginCodeEnv[default]}%
    }%
    {\end{VerbatimOut}%
    \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
    \ifbool{pytx@opt@autoprint}{\InputIfFileExists{\pytx@outputdir/\pytx@outfile}{}{}}{}%
    \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    \stepcounter{\pytx@counter}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BeginCodeEnv}
% This macro finishes setting things up before the |code| environment contents.  It processes the optional argument, defines a counter and checks its existence, writes info to the code file, and then calls the |\pytx@BeginCodeEnv@i| macro.  This macro is necessary so that the environment can accept two optional arguments.  Since the |block| and |verb| environments can accept two optional arguments (the first is the name of the session, the second is |fancyvrb| options), the code environment also should be able to, to maintain parallelism (for example, |pyblock| should be able to be swapped with |pycode| without changing environment arguments---it should just work).  However, |VerbatimOut| doesn't take an optional argument.  So we need to capture and discard any optional argument, before starting |VerbatimOut|.
%    \begin{macrocode}
\def\pytx@BeginCodeEnv[#1]{%
    \ifstrempty{#1}{\edef\pytx@session{default}}{\StrSubstitute{#1}{:}{_}[\pytx@session]}%
    \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
    \pytx@CheckCounter{\pytx@counter}%
    \pytx@WriteCodefileInfo
    \begingroup
    \obeylines
    \@ifnextchar[{\endgroup\pytx@BeginCodeEnv@i}{\endgroup\pytx@BeginCodeEnv@i[]}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BeginCodeEnv@i}
% As described above, this macro captures a second optional argument, if present, and then starts the |VerbatimOut| environment.  Note that |VerbatimOut| does not have a mandatory argument, because we are invoking our custom |\pytx@FVB@VerbatimOut| macro.  The default |fancyvrb| macro needs an argument to tell it the name of the file to which to save the verbatim content.  But in our case, we are always writing to the same file, and the custom macro accounts for this by not having a mandatory file name argument.  We must perform the typical |FancyVerbLine| trickery, to prevent the |fancyvrb| line counter from being affected by \textbf{writing} content!
%    \begin{macrocode}
\def\pytx@BeginCodeEnv@i[#1]{%
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \begin{VerbatimOut}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Inline commands and environments with Pygments}
% After all that, we still aren't finished.  We need to create new versions of all the inline command and environment macros that will work with Pygments to typeset highlighted code!  Fortunately, we can just copy the previous code and then make some Pygments-specific modifications.  It turns out that the Pygments versions are actually a bit simpler in some respects.  The macro names are generally just the original macro names with ``Pyg'' added to the end.\footnote{It is tempting to accomodate Pygments by introducing branching at appropriate points in the |fancyvrb|-based commands and environments.  That could certainly be done.  But given the relatively small amount of code that must be modified and added in copied versions versions of the |fancyvrb|-based code, such an approach might not be worth the added complexity.  Perhaps this should be reconsidered in the future, given the potential advantages of a more unified and integrated code base if the accompanying complexity could be minimized.}
%
% Using Pygments means that \textbf{all} code must be written to the code file, not just code that is executed.  Now all code will be either executed or highlighted, or both.  Highlighted content could be brought back via |\input|.  But that would require that |pyghontex.py| create an external file for each command or environment of highlighted code, which would rapidly create a large number of external files.  Since one of \pytex's goals is to minimize additional file creation, we don't take that approach by default (the package option |pygextfile| allows this to be overridden when the length of Pygmentized code crosses a user-specified threshold).  Rather, we use |fancyvrb|'s |SaveVerbatim| environment, which allows verbatim content to be saved in a macro and reused.  All highlighted code is placed in a single file with appropriate |SaveVerbatim| commands, and only this file is brough into the document via |\input|.  (Again, since the saving process introduces a speed penalty, we have provided the |pygextfile| option.)
%
% So we shall need to use |fancyvrb|'s |SaveVerbatim| environment to include Pygments content.  Unfortunately, when the saved content is included in a document with the corresponding |UseVerbatim|, line numbering does not work correctly.  Based on a web search, this appears to be a known bug in |fancyvrb|.  We begin by fixing this, which requires patching |fancyvrb|'s |\FVB@SaveVerbatim| and |\FVE@SaveVerbatim|.  We create a patched |\pytx@FVB@SaveVerbatim| by inserting |\FV@StepLineNo| and |\FV@CodeLineNo=1| at appropriate locations.  We also delete an unnecessary |\gdef\SaveVerbatim@Name{#1}|.  Then we create a |\pytx@FVE@SaveVerbatim|, and add code so that the two macros work together to prevent |FancyVerbLine| from incorrectly being incremented within the |SaveVerbatim| environment.
%
% Typically, we |\let| our own custom macros to the corresponding macros within |fancyvrb|, but only within a command or environment.  In this case, however, we are fixing behavior that should be considered a bug even for normal |fancyvrb| usage.  So we let the buggy macros to the patched macros immediately after defining the patched versions.
%
% \begin{macro}{\pytx@FVB@SaveVerbatim}
%    \begin{macrocode}
\def\pytx@FVB@SaveVerbatim#1{%
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \@bsphack
    \begingroup
    \FV@UseKeyValues
    \def\SaveVerbatim@Name{#1}%
    \def\FV@ProcessLine##1{%
        \expandafter\gdef\expandafter\FV@TheVerbatim\expandafter{%
        \FV@TheVerbatim\FV@StepLineNo\FV@ProcessLine{##1}}}%
    \gdef\FV@TheVerbatim{\FV@CodeLineNo=1}%
    \FV@Scan}
\def\pytx@FVE@SaveVerbatim{%
    \expandafter\global\expandafter\let
    \csname FV@SV@\SaveVerbatim@Name\endcsname\FV@TheVerbatim
    \endgroup\@esphack
    \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}}
\let\FVB@SaveVerbatim\pytx@FVB@SaveVerbatim
\let\FVE@SaveVerbatim\pytx@FVE@SaveVerbatim
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Inline commands}
% \begin{macro}{\pytx@InlinePyg}
% The inline gateway macro is unchanged, except for the macros it calls.
%    \begin{macrocode}
\def\pytx@InlinePyg{%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\{=1
    \@ifnextchar[{\endgroup\pytx@InlineOargPyg}{\endgroup\pytx@InlineOargPyg[default]}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineOargPyg}
% The macro that gets the optional argument is unchanged, except for the macros it calls.
%    \begin{macrocode}
\def\pytx@InlineOargPyg[#1]{%
    \ifstrempty{#1}{\edef\pytx@session{default}}{\StrSubstitute{#1}{:}{_}[\pytx@session]}%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\{=1
    \catcode`\}=2
    \@ifnextchar\bgroup
        {\pytx@InlineMargBgroupPyg}%
        {\catcode`\{=12
        \catcode`\}=12
        \pytx@InlineMargOtherPyg}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineMargBgroupPyg}
% Now we get to changes.  Using Pygments changes how code is typeset.  |pythontex.py| takes the \LaTeX\ code that Pygments returns and puts it in a .tex file that is inputted into the document.  The formatted code from Pygments is placed inside |fancyvrb|'s |SaveVerbatim| environment, so that it can be retrieved using |UseVerbatim|.  The |SaveVerbatim| environment in which the formatted code is saved is named based on the type, session, group, and instance.  So we must check to see if Pygments output exists.  If so, we bring it in, using |BUseVerbatim| because we are inline.  We must perform the tiresome |FancyVerbLine| trickery.  If Pygments output doesn't exist, we instead insert boldface text to notify the user and also return a package warning.  We bring in the Pygments content inside a group to keep |fancyvrb| settings local.
%
% Note that while we still care about the |pytx@inline@show| option, we no longer care about the |pytx@inline@save| option.  This is because all code must now be saved, whether or not it is executed, so that it is available for highlighting by Pygments.
%    \begin{macrocode}
\def\pytx@InlineMargBgroupPyg#1{%
    \endgroup
    \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
    \pytx@CheckCounter{\pytx@counter}%
    \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
    \pytx@WriteCodefileInfo
    \immediate\write\pytx@codefile{#1}%
    \ifdefstring{\pytx@cmd}{inlinec}%
        {\ifbool{pytx@opt@autoprint}%
            {\InputIfFileExists{\pytx@outputdir/\pytx@outfile}{}{}}{}}{}%
    \ifdefstring{\pytx@cmd}{inline}%
        {\begin{NoHyper}\ref{\pytx@counter @\arabic{\pytx@counter}}\end{NoHyper}}{}%
    \ifbool{pytx@inline@show}{%
        \begingroup
        \pytx@FVSet
        \ifcsname FV@SV@\pytx@counter @\arabic{\pytx@counter}\endcsname
            \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
            \BUseVerbatim{\pytx@counter @\arabic{\pytx@counter}}%
            \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
        \else
            \textbf{??~\pytx@packagename~??}%
            \PackageWarning{\pytx@packagename}{Non-existent Pygments content}%
        \fi
        \endgroup
        \boolfalse{pytx@inline@show}%
    }{}%
    \stepcounter{\pytx@counter}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineMargOtherPyg}
% If we are dealing with delimiters other than matched curly braces, the code remains the same except for macro names, until the |\pytx@InlineMargOtherGetPyg@i| macro.
%    \begin{macrocode}
\def\pytx@InlineMargOtherPyg#1{%
    \endgroup
    \ifstrequal{#1}{\pytx@spacecattwelve}%
        {\PackageError{\pytx@packagename}%
            {The space character cannot be used as a delimiting character}%
            {Choose another delimiting character}}%
        {\def\pytx@InlineMargOtherGetPyg##1#1{%
            \endgroup
            \def\pytx@arg{##1}%
            \pytx@InlineMargOtherGetPyg@i}}%
    \begingroup
    \let\do\@makeother\dospecials
    \catcode`\ =\active
    \pytx@InlineMargOtherGetPyg
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@InlineMargOtherGetPyg@i}
% We bring in Pygments content as before.  We check if saved verbatim content from Pygments exist, and if so, bring it in, performing the standard counter games.  Otherwise, we notify the user via boldface text in the document as well as by a package warning.  Again, we save all content so that Pygments can process it, even if it ins't executed.
%    \begin{macrocode}
\def\pytx@InlineMargOtherGetPyg@i{%
    \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
    \pytx@CheckCounter{\pytx@counter}%
    \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
    \pytx@WriteCodefileInfo
    \immediate\write\pytx@codefile{\pytx@arg}%
    \ifdefstring{\pytx@cmd}{inlinec}%
        {\ifbool{pytx@opt@autoprint}%
            {\InputIfFileExists{\pytx@outputdir/\pytx@outfile}{}{}}{}}{}%
    \ifdefstring{\pytx@cmd}{inline}%
        {\begin{NoHyper}\ref{\pytx@counter @\arabic{\pytx@counter}}\end{NoHyper}}{}%
    \ifbool{pytx@inline@show}{%
        \begingroup
        \pytx@FVSet
        \ifcsname FV@SV@\pytx@counter @\arabic{\pytx@counter}\endcsname
            \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
            \BUseVerbatim{\pytx@counter @\arabic{\pytx@counter}}%
            \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
        \else
            \textbf{??~\pytx@packagename~??}%
            \PackageWarning{\pytx@packagename}{Non-existent Pygments content}%
        \fi
        \endgroup
        \boolfalse{pytx@inline@show}%
    }{}%
    \stepcounter{\pytx@counter}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% Now that we have a Pygments version of the core inline macros, we create Pygments versions of the constructors.  Note that we now only have to specify whether code is shown; all code must be saved so that it can be processed by Pygments.
% \begin{macro}{\pytx@MakeInlinebPyg}
% A constructor for inline block commands.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlinebPyg}[1]{%
    \expandafter\newcommand\expandafter{\csname #1b\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inlineb}%
        \pytx@SetStyle
        \booltrue{pytx@inline@show}%
        \pytx@InlinePyg
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeInlinevPyg}
% A constructor for inline verbatim commands.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlinevPyg}[1]{%
    \expandafter\newcommand\expandafter{\csname #1v\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inlinev}%
        \pytx@SetStyle
        \booltrue{pytx@inline@show}%
        \pytx@InlinePyg
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeInlinecPyg}
% A constructor for inline code commands.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlinecPyg}[1]{%
    \expandafter\newcommand\expandafter{\csname #1c\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inlinec}%
        \pytx@SetStyle
        \pytx@InlinePyg
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeInlinePyg}
% A constructor for inline commands, bringing back output as labels.
%    \begin{macrocode}
\newcommand{\pytx@MakeInlinePyg}[1]{%
    \expandafter\newcommand\expandafter{\csname #1\endcsname}{%
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{inline}%
        \pytx@SetStyle
        \pytx@InlinePyg
    }%
}%
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Environments}
% Since all code must be saved now (either to be executed or processed by Pygments, or both), the environment code may be simplified compared to the non-Pygments case.
% \begin{macro}{\pytx@MakePygEnv}
% The |block| and |verb| environments are created via the same macro.  The |\pytx@MakePygEnv| macro takes two arguments:  first, the code type, and second, the environment (|block| or |verb|).  The reason for using the same macro is that both must now save their code externally, and bring back the result typeset by Pygments.  Thus, on the \LaTeX\ side, their behavior is identical.  The only difference is on the Python side, where the block code is executed and thus there may be output available via |\printpythontex| and company.
%
% The actual workings of the macro are a combination of those of the non-Pygments macros, so please refer to those for details.  The only exception is the code for bringing in Pygments output, but this is done using almost the same approach as that used for the inline Pygments commands.  There are two differences:  first, the |block| and |verb| environments use |\UseVerbatim| rather than |\BUseVerbatim|, since they are not typesetting code inline; and second, they accept a second, optional argument containing |fancyvrb| commands and this is used in typesetting the saved content.  Any |fancyvrb| commands are saved in |\pytx@fvopttmp| by |\pytx@BeginEnvPyg@i|, and then used when the code is typeset.
%
% Note that the positioning of all the |FancyVerbLine| trickery in what follows is significant.  Saving the |FancyVerbLine| counter to a temporary counter before the beginning of |VerbatimOut| is important, because otherwise the |fancyvrb| numbering can be affected.
%
%    \begin{macrocode}
\newcommand{\pytx@MakePygEnv}[2]{%
    \expandafter\newenvironment{#1#2}{%
        \VerbatimEnvironment
        \xdef\pytx@type{#1}%
        \edef\pytx@cmd{#2}%
        \pytx@SetStyle
        \let\FVB@VerbatimOut\pytx@FVB@VerbatimOut
        \let\FVE@VerbatimOut\pytx@FVE@VerbatimOut
        \begingroup
        \obeylines
        \@ifnextchar[{\endgroup\pytx@BeginEnvPyg}{\endgroup\pytx@BeginEnvPyg[default]}%
    }%
    {\end{VerbatimOut}%
    \xdef\pytx@outfile{\pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.stdout}%
    \setcounter{FancyVerbLine}{\value{\pytx@linecount}}%
    \begingroup
    \pytx@FVSet
    \ifdefstring{\pytx@fvopttmp}{}{}{\expandafter\fvset\expandafter{\pytx@fvopttmp}}%
    \ifcsname FV@SV@\pytx@counter @\arabic{\pytx@counter}\endcsname
        \UseVerbatim{\pytx@counter @\arabic{\pytx@counter}}%
    \else
        \InputIfFileExists{\pytx@outputdir/\pytx@outfile.pygtex}{}%
            {\textbf{??~\pytx@packagename~??}%
                \PackageWarning{\pytx@packagename}{Non-existent Pygments content}}%
    \fi
    \endgroup
    \setcounter{\pytx@linecount}{\value{FancyVerbLine}}%
    \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    \stepcounter{\pytx@counter}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BeginEnvPyg}
% This macro finishes preparing for the content of a |verb| or |block| environment with Pygments content.  It captures an optional argument corresponding to the session name and sets up instance and line counters.  Finally, it calls an additional macro that handles the possibility of a second optional argument.
%    \begin{macrocode}
\def\pytx@BeginEnvPyg[#1]{%
    \ifstrempty{#1}{\edef\pytx@session{default}}{\StrSubstitute{#1}{:}{_}[\pytx@session]}%
    \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
    \pytx@CheckCounter{\pytx@counter}%
    \edef\pytx@linecount{\pytx@counter @line}%
    \pytx@CheckCounter{\pytx@linecount}%
    \pytx@WriteCodefileInfo
    \begingroup
    \obeylines
    \@ifnextchar[{\endgroup\pytx@BeginEnvPyg@i}{\endgroup\pytx@BeginEnvPyg@i[]}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BeginEnvPyg@i}
% This macro captures a second optional argument, corresponding to |fancyvrb| options.  Note that not all |fancyvrb| options may be passed to saved content when it is actually used, particularly those corresponding to how the content was read in the first place (for example, command characters).  But at least most formatting options such as line numbering work fine.  As with the non-Pygments environments, |\begin{VerbatimOut}| doesn't take a second mandatory argument, since we are using a custom version and don't need to specify the file in which Verbatim content is saved.  It is important that the |FancyVerbLine| saving be done here; if it is done later, after the end of |VerbatimOut|, then numbering can be off in some circumstances (for example, a single |pyverb| between two |Verbatim|'s).
%    \begin{macrocode}
\def\pytx@BeginEnvPyg@i[#1]{%
    \def\pytx@fvopttmp{#1}%
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \begin{VerbatimOut}%
}%
%    \end{macrocode}
% \end{macro}
%
% Since we are using the same code to create both |block| and |verb| environments, we now create a specific macro for creating each case, to make usage equivalent to that for the non-Pygments case.
% \begin{macro}{\pytx@MakeBlockPyg}
% The block environment is constructed via the |\pytx@MakePygEnv| macro.
%    \begin{macrocode}
\newcommand{\pytx@MakeBlockPyg}[1]{\pytx@MakePygEnv{#1}{block}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakeVerbPyg}
% The verb environment is constructed likewise.
%    \begin{macrocode}
\newcommand{\pytx@MakeVerbPyg}[1]{\pytx@MakePygEnv{#1}{verb}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pytx@MakeCodePyg}
% Since the code environment simply saves code for execution and typesets nothing, the Pygments version is identical to the non-Pygments version, so we simply let the former to the latter.
%    \begin{macrocode}
\let\pytx@MakeCodePyg\pytx@MakeCode
%    \end{macrocode}
% \end{macro}
%
% \subsection{Constructors for macro and environment families}
% Everything is now in place to create inline commands and environments, with and without Pygments usage.  To make all of this more readily usable, we need macros that will create a whole family of commands and environments at once, based on a base name.  For example, we need a way to easily create all commands and environments based off of the |py| base name.
%
% \begin{macro}{\makepythontexmacrosfv}
% This is a mass constructor for all commands and environments.  It takes a single argument:  a base name.  It creates all commands and environments using the base name.  It also creates |fancyvrb| settings corresponding to the family, and sets them to a null default.
%
% The macro checks for the base name |PYG|, which is not allowed.  This is for two reasons.  First, given that the family |py| is already defined by default, another family with such a similar name would not be a good idea.  Second, and more importantly, the prefix |PYG| is used for other purposes.  Although \pytex\ is primarily intended for executing and typesetting Python code, provision has also been made for typesetting code in any language supported by Pygments.  The |PYG| prefix is used by the macros that perfom that function.
%
% The constructor macro should only be allowed in the preamble, since commands and environments must be defined before the document begins.
%    \begin{macrocode}
\newcommand{\makepythontexmacrosfv}[1]{%
    \IfBeginWith{#1}{PYG}%
        {\PackageError{\pytx@packagename}%
            {Attempt to create macros with reserved prefix PYG}{}}{}
    \pytx@MakeInlineb{#1}
    \pytx@MakeInlinev{#1}
    \pytx@MakeInlinec{#1}
    \pytx@MakeInline{#1}
    \pytx@MakeBlock{#1}
    \pytx@MakeVerb{#1}
    \pytx@MakeCode{#1}
    \setpythontexfv[#1]{}
}%
\@onlypreamble\makepythontexmacrosfv
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\makepythontexmacrospyg}
% Creating a family of Pygments commands and environments is a little more involved.  This macro takes three arguments:  the base name, the Pygments lexer to be used, and Pygments options for typesetting.  Currently, three options may be passed to Pygments in this manner:  |style=|\meta{style~name}, which sets the formatting style; |texcomments|, which allows \LaTeX\ in code comments to be rendered; and |mathescape|, which allows \LaTeX\ math mode (|$...$|) in comments.  The |texcomments| and |mathescape| options may be used with an argument (for example, |texcomments=|\meta{True/False}); if an argument is not supplied, |True| is assumed.  Note that these settings may be overridden by the package option |pygments|.
%
% After checking for the disallowed prefix |PYG|, we begin by creating all commands and environments, and creating a macro in which to store default |fancyvrb| setting.  We save the Pygments settings in a macro of the form |\pytx@pygopt@|\meta{base~name}.  We also set the bool |pytx@usedpygments| to true, so that Pygments content will be inputted at the beginning of the document.  Then we request that the base name, lexer, and any Pygments settings be written to the code file at the beginning of the document, so that Pygments can access them.  The options are saved in a macro, and then the macro is saved to file only at the beginning of the document, so that the user can modify default options for default code and environment families.
%
% This macro should only be allowed in the preamble.
%    \begin{macrocode}
\newcommand{\makepythontexmacrospyg}[3]{%
    \IfBeginWith{#1}{PYG}%
        {\PackageError{\pytx@packagename}%
            {Attempt to create macros with reserved prefix PYG}{}}{}
    \pytx@MakeInlinebPyg{#1}
    \pytx@MakeInlinevPyg{#1}
    \pytx@MakeInlinecPyg{#1}
    \pytx@MakeInlinePyg{#1}
    \pytx@MakeBlockPyg{#1}
    \pytx@MakeVerbPyg{#1}
    \pytx@MakeCodePyg{#1}
    \setpythontexfv[#1]{}
    \booltrue{pytx@usedpygments}
    \expandafter\xdef\csname pytx@pygopt@#1\endcsname{#3}
    \AtBeginDocument{\immediate\write\pytx@codefile{%
        \pytx@delimparam pygmentsfamily:#1,#2,%
        \string{\csname pytx@pygopt@#1\endcsname\string}\pytx@delimchar}%
    }%
}%
\@onlypreamble\makepythontexmacrospyg
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\setpythontexpygopt}
% The user may wish to modify the Pygments options associated with a family.  This macro takes two arguments:  first, the family base name; and second, the Pygments options to associate with the family.  This macro is particularly useful in changing the Pygments style of default command and environment families.
%
% Due to the implementation (and also in the interest of keeping typesetting consistent), the Pygments style for a family must remain constant throughout the document.  Thus, we only allow changes to the style in the preamble.
%    \begin{macrocode}
\newcommand{\setpythontexpygopt}[2]{%
    \ifcsname pytx@pygopt@#1\endcsname
        \expandafter\xdef\csname pytx@pygopt@#1\endcsname{#2}%
    \else
        \PackageError{\pytx@packagename}%
            {Cannot modify Pygments options for a non-existent family}{}
    \fi
}%
\@onlypreamble\setpythontexpygopt
%    \end{macrocode}
%
% \begin{macro}{\makepythontexmacros}
% While the |\makepythontexmacrosfv| and |\makepythontexmacrospyg| macros allow the creation of families that use |fancyvrb| and Pygments, respectively, we want to be able to create families that can switch between the two options, based on the package option |pygments|.  In some cases, we may want to force a family to use either |fancyvrb| or Pygments, but often we will want to be able to control the method of typesetting of all families at the package level.  We create a new macro for this purpose.  This macro takes the same arguments that |\makepythontexmacrospyg| does:  the family base name, the lexer to be used by Pygments, and Pygments options for typesetting.  It also takes an optional argument (|auto|, |fancyvrb|, or |pygments|), which allows the package |pygments| option to be overridden, effectively reducing the macro to either |\makepythontexmacrosfv| or |\makepythontexmacrospyg|.  The actual creation of macros is delayed using |\AtBeginDocument|, so that the user has the option to override default optional settings.
%    \begin{macrocode}
\newcommand{\makepythontexmacros}[4][auto]{%
    \expandafter\xdef\csname pytx@macroformatter@#2\endcsname{#1}
    \expandafter\xdef\csname pytx@pyglexer@#2\endcsname{#3}
    \expandafter\xdef\csname pytx@pygopt@#2\endcsname{#4}
    \AtBeginDocument{%
        \ifcsstring{pytx@macroformatter@#2}{auto}{%
            \ifbool{pytx@opt@pygments}%
                {\makepythontexmacrospyg{#2}{\csname pytx@pyglexer@#2\endcsname}%
                    {\csname pytx@pygopt@#2\endcsname}}%
                {\makepythontexmacrosfv{#2}}}{}%
        \ifcsstring{pytx@macroformatter@#2}{fancyvrb}%
            {\makepythontexmacrosfv{#2}}{}%
        \ifcsstring{pytx@macroformatter@#2}{pygments}%
            {\makepythontexmacrospyg{#2}{\csname pytx@pyglexer@#2\endcsname}%
                {\csname pytx@pygopt@#2\endcsname}}{}%
    }%
}%
\@onlypreamble\makepythontexmacros
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\setpythontexmacros}
% To give the user full control, we also require a way to reset a family after it is created.  For example, the default families created by \pytex\ should be able to be modified.  For this purpose, we create a general macro and two specific macros.  In all cases, we check to make sure that a family exists before attempting to change its settings.
%    \begin{macrocode}
\newcommand{\setpythontexmacros}[4][auto]{%
    \ifcsname pytx@macroformatter@#2\endcsname
        \expandafter\xdef\csname pytx@macroformatter@#2\endcsname{#1}
        \expandafter\xdef\csname pytx@pyglexer@#2\endcsname{#3}
        \expandafter\xdef\csname pytx@pygopt@#2\endcsname{#4}
    \else
        \PackageError{\pytx@packagename}%
            {Cannot modify a non-existent family}{}
    \fi
}%
\@onlypreamble\setpythontexmacros
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\setpythontexformatter}
% We need to be able to reset the formatter among |auto|, |fancyvrb|, and |pygments|.
%    \begin{macrocode}
\def\setpythontexformatter#1#2{%
    \ifcsname pytx@macroformatter@#1\endcsname
        \expandafter\xdef\csname pytx@macroformatter@#1\endcsname{#2}
    \else
        \PackageError{\pytx@packagename}%
            {Cannot modify a non-existent family}{}
    \fi
}%
\@onlypreamble\setpythontexformatter
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\setpythontexpyglexer}
% We need to be able to reset the lexer.
%    \begin{macrocode}
\def\setpythontexpyglexer#1#2{%
    \ifcsname pytx@pyglexer@#1\endcsname
        \expandafter\xdef\csname pytx@pyglexer@#1\endcsname{#2}
    \else
        \PackageError{\pytx@packagename}%
            {Cannot modify a non-existent family}{}
    \fi
}%
\@onlypreamble\setpythontexpyglexer
%    \end{macrocode}
% \end{macro}
% 
% We have already created the |\setpythontexpygopt| macro, which would also logically belong here if it didn't already exist, when we created |\makepythontexmacrospyg|.
%
%
% \subsection{Default commands and environments}
% Finally, we can create the default command and environment families.  We create a basic Python family with the base name |py|.  We also create customized Python families for the SymPy package, using the base name |sympy|, and for the pylab module, using the base name |pylab|.
%
% All of these command and environment families are created conditionally, depending on whether the package option |pygments| is used, via |\makepythontexmacros|.  We recommend that any custom families created by the user be constructed in the same manner.
%    \begin{macrocode}
\makepythontexmacros{py}{python}{}
\makepythontexmacros{sympy}{python}{}
\makepythontexmacros{pylab}{python}{}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Listings environment}
% |fancyvrb|, especially when combined with Pygments, provides most of the formatting options we could want.  However, it simply typesets code within the flow of the document and does not provide a floating environment.  So we create a floating environment for code listings via the |newfloat| package.
%
% It is most logical to name this environment |listing|, but that is already defined by the |minted| package (although  \pytex\ and |minted| are probably not likely to be used together, due to overlapping features).  Furthermore, the |listings| package specifically avoided using the name |listing| for environments due to its use by other packages.
%
% We have chosen to make a compromise.  We create a macro that creates a float environment with a custom name for listings.  If this macro is invoked, then a float environment for listings exists and nothing else is done.  If it is not invoked, the package attempts to create an environment called |listing| at the beginning of the document, and issues a warning if another macro with that name already exists.  This approach makes the logical |listing| name available in most cases, and provides the user with a simple fallback in the event that another package defining |listing| must be used alongside \pytex.
%
% \begin{macro}{\setpythontexlistingenv}
% We define a bool |pytx@listingenv| that keeps track of whether a listings environment has been created.  Then we define a macro that creates a floating environment with a custom name, with appropriate settings for a listing environment.  We only allow this macro to be used in the preamble, since later use would wreak havok.
%    \begin{macrocode}
\newbool{pytx@listingenv}
\def\setpythontexlistingenv#1{
    \DeclareFloatingEnvironment[fileext=lopytx,listname={List of Listings},name=Listing]{#1}
    \booltrue{pytx@listingenv}
}
\@onlypreamble\setpythontexlistingenv
%    \end{macrocode}
% \end{macro}
%
% At the beginning of the document, we issue a warning if the |listing| environment needs to be created but cannot be due to a pre-existing macro (and no version with a custom name has been created).  Otherwise, we create the |listing| environment.
%    \begin{macrocode}
\AtBeginDocument{
    \ifcsname listing\endcsname
        \ifbool{pytx@listingenv}{}%
            {\PackageWarning{\pytx@packagename}%
                {A conflicting listing environment already exists}%
                {Create a \pytx@packagename\ listing environment with a custom name}}%
    \else
        \ifbool{pytx@listingenv}{}{\DeclareFloatingEnvironment[fileext=lopytx]{listing}}
    \fi
}%
%    \end{macrocode}
%
% \subsection{Pygments for general code typesetting}
% After all the work that has gone into \pytex\ thus far, it would be a pity not to slightly expand the system to allow Pygments typesetting of any language it supports, not just Python.  While \pytex\ currently can only \textit{execute} Python code, it is relatively easy to add support for \textit{highlighting} any language supported by Pygments.  We proceed to create a |\pygment| command, a |pygments| environment, and an |\inputpygments| command that do just this.  The functionality of these is very similar to that provided by the |minted| package.
%
% Both the commands and the environment are created in two forms:  one that actually uses Pygments, which is the whole point in the first place; and one that uses |fancyvrb|, which may speed compilation or make editing faster since |pythontex.py| need not be invoked.  By default, the two forms are switched between based on the package |pygments| option, but this may be easily modified as described below.
%
% The Pygments commands and environment operate under the code type |PYG|\meta{lexer~name}.  This allows Pygments typesetting of general code to proceed with very few additions to |pythontex.py|; in most situations, the Pygments code types behave just like standard \pytex\ types that don't execute any code.  Due to the use of the |PYG| prefix for all Pygments content, the use of this prefix is not allowed at the beginning of a base name for standard \pytex\ command and environment families.
%
% We have previously used the suffix |Pyg| to denote macro variants that use Pygments rather than |fancyvrb|.  We continue that practice here.  To distinguish the special Pygments typesetting macros from the regular \pytex\ macros, we use |Pygments| in the macro names, in addition to any |Pyg| suffix
%
%
% \subsubsection{Primary commands and environment using Pygments}
% We begin by creating the primary commands and environment, which make use of Pygments.  These are largely based on the Pygments variant of the \pytex\ |verb| environment.
%
%
% \begin{macro}{\pytx@MakePygmentsInlinePyg}\begin{macro}{\pygment}
% This macro hooks into the pre-existing |\pytx@InlinePyg| macro sequence.  It is very similar to the constructors for inline commands using Pygments, except for the way in which the type is defined and the fact that we have to check to see if a macro for |fancyvrb| settings exists.  Just as for the \pytex\ inline commands, we do not currently support |fancyvrb| options in Pygments inline commands, since almost all options are impractical for inline usage, and the few that might conceivably be practical, such as showing spaces, should probably be used throughout an entire document rather than just for a tiny code snippet within a paragraph.
%
% The approach of reusing the inline code is very efficient; the major loss is that the inline code checks for an optional argument denoting session.  We supply an empty optional argument to |\pytx@InlinePyg|, so that the |\pygment| command can only take two mandatory arguments, and no optional argument (since sessions don't make sense for code that is merely typeset):  |\pygment|\marg{lexer}\marg{code}.
%    \begin{macrocode}
\def\pytx@MakePygmentsInlinePyg{%
    \newcommand{\pygment}[1]{%
        \edef\pytx@type{PYG##1}%
        \edef\pytx@cmd{inlinev}%
        \pytx@SetStyle
        \booltrue{pytx@inline@show}%
        \ifcsname pytx@fvsettings@\pytx@type\endcsname
        \else
            \expandafter\def\csname pytx@fvsettings@\pytx@type\endcsname{}%
        \fi
        \pytx@InlinePyg[]
    }%
}%
%    \end{macrocode}
% \end{macro}\end{macro}
%
%
% \begin{macro}{\pytx@MakePygmentsEnvPyg}\begin{macro}{pygments}
% The |pygments| environment is created to take an optional argument, which corresponds to |fancyvrb| settings, and one mandatory argument, which corresponds to the Pygments lexer to be used in highlighting the code.
%
% The |pygments| environment begins by declaring that it is a |Verbatim| environment, setting the style (probably unnecessary, but it maintains uniformity with other \pytex\ environments), letting patched macros to buggy macros, and then capturing an optional argument and a mandatory argument via a series of external macros.  As in previous cases, |\obeylines| is necessary to ensure that only the line containing |\begin{pygments}| is checked for arguments.
%
% At the end of the environment, we close the |VerbatimOut| environment begun by |\pytx@BEPygmentsPyg@i|, swap counters, invoke |fancyvrb| formatting and typeset content if it is available, swap counters back, and step the counter that keeps track of instances.
%    \begin{macrocode}
\def\pytx@MakePygmentsEnvPyg{%
    \newenvironment{pygments}{%
        \VerbatimEnvironment
        \pytx@SetStyle
        \let\FVB@VerbatimOut\pytx@FVB@VerbatimOut
        \let\FVE@VerbatimOut\pytx@FVE@VerbatimOut
        \begingroup
        \obeylines
        \@ifnextchar[{\endgroup\pytx@BEPygmentsPyg}{\endgroup\pytx@BEPygmentsPyg[]}%
    }%
    {\end{VerbatimOut}%
        \setcounter{FancyVerbLine}{\value{\pytx@linecount}}%
        \begingroup
        \pytx@FVSet
        \ifdefstring{\pytx@fvopttmp}{}{}{\expandafter\fvset\expandafter{\pytx@fvopttmp}}%
        \ifcsname FV@SV@\pytx@counter @\arabic{\pytx@counter}\endcsname
            \UseVerbatim{\pytx@counter @\arabic{\pytx@counter}}%
        \else
            \InputIfFileExists{\pytx@outputdir/%
                \pytx@type_\pytx@session_\pytx@group_\arabic{\pytx@counter}.pygtex}{}%
                {\textbf{??~\pytx@packagename~??}%
                    \PackageWarning{\pytx@packagename}{Non-existent Pygments content}}%
        \fi
        \endgroup
        \setcounter{\pytx@linecount}{\value{FancyVerbLine}}%
        \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
        \stepcounter{\pytx@counter}%
    }%
}%
%    \end{macrocode}
% \end{macro}\end{macro}
%
%
% \begin{macro}{\pytx@BEPygmentsPyg}
% This macro captures the optional argument, which corresponds to |fancyvrb| settings.  It stores these in the |\pytx@fvopttmp| macro and then calls the macro that captures the mandatory argument.
%    \begin{macrocode}
\def\pytx@BEPygmentsPyg[#1]{%
    \def\pytx@fvopttmp{#1}%
    \begingroup
    \obeylines
    \pytx@BEPygmentsPyg@i
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pytx@BEPygmentsPyg@i}
% This macro captures the mandatory argument.  It begins by closing the group from the previous macro, which had used |\obeylines| to ensure that the mandatory argument was coming from the same line as the |\begin{pygments}| command for the environment.  The code type is defined using the mandatory argument, which corresponds to the Pygments lexer to be used on the code, combined with the prefix |PYG|.  The command type is set to |verb|, so that |pythontex.py| will treat it as verbatim content and not try to execute it.  The session is set to a default value; currently, it is simply superfluous.  Instance and line counters are created and checked, and basic information is written to the code file.  Then we check to see if a |fancyvrb| settings macro exists for the current code type, and if not create an empty one.  This is necessary because all possible code types are not known in advance, and thus we cannot create macros for their |fancyvrb| settings elsewhere.  Finally, we begin the |VerbatimOut| environment.
%    \begin{macrocode}
\def\pytx@BEPygmentsPyg@i#1{%
    \endgroup
    \edef\pytx@type{PYG#1}%
    \edef\pytx@cmd{verb}%
    \edef\pytx@session{default}%
    \edef\pytx@counter{pytx@\pytx@type @\pytx@session @\pytx@group}%
    \pytx@CheckCounter{\pytx@counter}%
    \edef\pytx@linecount{\pytx@counter @line}%
    \pytx@CheckCounter{\pytx@linecount}%
    \pytx@WriteCodefileInfo
    \ifcsname pytx@fvsettings@\pytx@type\endcsname
    \else
        \expandafter\def\csname pytx@fvsettings@\pytx@type\endcsname{}%
    \fi
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \begin{VerbatimOut}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakePygmentsInputPyg}
% For completeness, we need to be able to read in a file and highlight it.  This is done through some trickery with the current system.  We define the type as |PYG|\meta{lexer}, and the command as |verb| so that it will not be executed.  We set the style, which is currently unused.  We set the session as |EXT:|\meta{file~name}.  Next we define a |fancyvrb| settings macro for the type if it does not already exist.  We write info to the code file using |\pytx@WriteCodefileInfoExt|, which writes the standard info to the code file but uses zero for the instance, since external files that are not executed can only have one instance.
%
% Then we check to see if the file actually exists, and issue a warning if not.  The saves the user from running |pythontex.py| to get the same error.  We perform our typical |FancyVerbLine| trickery.  Next we make use of the saved content in the same way as the |pygments| environment.  Note that we do not create a counter for the line numbers.  This is because under typical usage an external file should have its lines numbered beginning with 1.  We also encourage this by setting |firstnumber=auto| before bringing in the content.
%
% The current naming of the macro in which the Pygments content is saved is probably excessive.  In almost every situation, a unique name could be formed with less information.  The current approach has been taken to maintain parallelism, thus simplifying |pythontex.py|, and to avoid any rare potential conflicts.
% 
%    \begin{macrocode}
\def\pytx@MakePygmentsInputPyg{
    \newcommand{\inputpygments}[3][]{%
        \edef\pytx@type{PYG##2}%
        \edef\pytx@cmd{verb}%
        \pytx@SetStyle
        \edef\pytx@session{EXT:##3}%
        \ifcsname pytx@fvsettings@\pytx@type\endcsname
        \else
            \expandafter\def\csname pytx@fvsettings@\pytx@type\endcsname{}%
        \fi
        \pytx@WriteCodefileInfoExt
        \IfFileExists{##3}{}{\PackageWarning{\pytx@packagename}%
            {Input file <##3> does not exist}{}}
        \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
        \begingroup
        \pytx@FVSet
        \fvset{firstnumber=auto}%
        \ifcsname FV@SV@pytx@\pytx@type @\pytx@session @\pytx@group @0\endcsname
            \UseVerbatim[##1]{pytx@\pytx@type @\pytx@session @\pytx@group @0}%
        \else
            \InputIfFileExists{\pytx@outputdir/##3_##2.pygtex}{}%
                {\textbf{??~\pytx@packagename~??}%
                    \PackageWarning{\pytx@packagename}{Non-existent Pygments content}}%
        \fi
        \endgroup
        \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Alternate commands and environment using fancyvrb}
%
% Though the Pygments commands and environment that actually use Pygments will be used most, we provide a |fancyvrb| form of each.
%
% \begin{macro}{\pytx@MakePygmentsInline}
% This macro creates an inline command using |fancyvrb|.  It reuses the |\pytx@Inline| macro sequence, and is analogous to |\pytx@MakePygmentsInlinePyg|.
%    \begin{macrocode}
\def\pytx@MakePygmentsInline{%
    \newcommand{\pygment}[1]{%
        \edef\pytx@type{PYG##1}%
        \edef\pytx@cmd{inlinev}%
        \pytx@SetStyle
        \booltrue{pytx@inline@show}%
        \ifcsname pytx@fvsettings@\pytx@type\endcsname
        \else
            \expandafter\def\csname pytx@fvsettings@\pytx@type\endcsname{}%
        \fi
        \pytx@Inline[]
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakePygmentsEnv}\begin{macro}{pygments}
% This macro creates a |pygments| environment that uses |fancyvrb|.
%    \begin{macrocode}
\def\pytx@MakePygmentsEnv{%
    \newenvironment{pygments}{%
        \VerbatimEnvironment
        \pytx@SetStyle
        \begingroup
        \obeylines
        \@ifnextchar[{\endgroup\pytx@BEPygments}{\endgroup\pytx@BEPygments[]}%
    }%
    {\end{Verbatim}\endgroup%
        \setcounter{\pytx@linecount}{\value{FancyVerbLine}}%
        \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    }%
}%
%    \end{macrocode}
% \end{macro}\end{macro}
%
%
% \begin{macro}{\pytx@BEPygments}
% This macro captures the optional argument containing |fancyvrb| commands.
%    \begin{macrocode}
\def\pytx@BEPygments[#1]{%
    \def\pytx@fvopttmp{#1}%
    \begingroup
    \obeylines
    \pytx@BEPygments@i
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@BEPygments@i}
% This macro captures the mandatory argument, containing the lexer name.
%    \begin{macrocode}
\def\pytx@BEPygments@i#1{%
    \endgroup
    \edef\pytx@type{PYG#1}%
    \edef\pytx@cmd{verb}%
    \edef\pytx@session{default}%
    \edef\pytx@linecount{pytx@\pytx@type @\pytx@session @\pytx@group @line}%
    \pytx@CheckCounter{\pytx@linecount}%
    \ifcsname pytx@fvsettings@\pytx@type\endcsname
    \else
        \expandafter\def\csname pytx@fvsettings@\pytx@type\endcsname{}%
    \fi
    \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
    \setcounter{FancyVerbLine}{\value{\pytx@linecount}}%
    \begingroup\pytx@FVSet
    \ifdefstring{\pytx@fvopttmp}{}{}{\expandafter\fvset\expandafter{\pytx@fvopttmp}}%
    \begin{Verbatim}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pytx@MakePygmentsInput}
% For completeness, we need a macro that can read in an external file via |fancyvrb| and typeset it.  We define the type, create |fancyvrb| settings if necessary, and then begin a group in which we use |VerbatimInput|.  We set |firstnumber| to |auto| to make sure that |fancyvrb| or other settings don't leak over and cause improper line numbering; line numbering should begin with 1, unless explicitly set by the user within the command.  We must also save and restore the counter |FancyVerbLine| to prevent |fancyvrb| from being affected.
%    \begin{macrocode}
\def\pytx@MakePygmentsInput{
    \newcommand{\inputpygments}[3][]{%
        \edef\pytx@type{PYG##2}%
        \edef\pytx@cmd{verb}%
        \pytx@SetStyle
        \edef\pytx@session{EXT:##3}%
        \ifcsname pytx@fvsettings@\pytx@type\endcsname
        \else
            \expandafter\def\csname pytx@fvsettings@\pytx@type\endcsname{}%
        \fi
        \setcounter{pytx@FancyVerbLineTemp}{\value{FancyVerbLine}}%
        \begingroup
        \pytx@FVSet
        \fvset{firstnumber=auto}%
        \IfFileExists{##3}%
            {\VerbatimInput[##1]{##3}}%
            {\PackageWarning{\pytx@packagename}{Input file <##3> doesn't exist}}%
        \endgroup
        \setcounter{FancyVerbLine}{\value{pytx@FancyVerbLineTemp}}%
    }%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Creating the Pygments commands and environment}
%
% We are almost ready to actually create the Pygments commands and environments.  First, though, we create some macros that allow the user to set |fancyvrb| settings, Pygments options, and formatting of Pygments content.
% \begin{macro}{\setpygmentsfv}
% This macro allows |fancyvrb| settings to be specified for a Pygments lexer.  It takes the lexer name as the optional argument and the settings as the mandatory argument.  If no optional argument (lexer) is supplied, then it sets the document-wide |fancyvrb| settings, and is in that case equivalent to |\setpythontexfv|.
%    \begin{macrocode}
\newcommand{\setpygmentsfv}[2][]{%
    \ifstrempty{#1}%
        {\gdef\pytx@fvsettings{#2}}%
        {\expandafter\gdef\csname pytx@fvsettings@PYG#1\endcsname{#2}}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\setpygmentspygopt}
% This macro allows the Pygments option to be set for a lexer.  It takes the lexer name as the first argument and the options as the second argument.  If this macro is used multiple times for a lexer, it will write the settings to the code file multiple times.  But |pythontex.py| will simply process all settings, and each subsequent set of settings will overwrite any prior settings, so this is not a problem.
%    \begin{macrocode}
\def\setpygmentspygopt#1#2{%
    \AtBeginDocument{\immediate\write\pytx@codefile{%
        \pytx@delimparam pygmentsfamily:PYG#1,#1,%
        \string{#2\string}\pytx@delimchar}%
    }%
}%
\@onlypreamble\setpygmentspygopt
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\setpygmentsformatter}
% This macro sets the formatter (Pygments or |fancyvrb|) that is used by the Pygments commands and environment.  There are three options:  |auto|, which depends on the package |pygments| option; and |pygments| and |fancyvrb|, which override the package option.  By default, Pygments is used, overriding the package |pygments| option.
%    \begin{macrocode}
\def\setpygmentsformatter#1{\xdef\pytx@macroformatter@PYG{#1}}
\@onlypreamble\setpygmentsformatter
\setpygmentsformatter{pygments}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\makepygmentspyg}
% This macro creates the Pygments commands and environment using Pygments.  We must set the bool |pytx@usedpygments| true so that |pythontex.py| knows that Pygments content is present and must be highlighted.
%    \begin{macrocode}
\def\makepygmentspyg{%
    \pytx@MakePygmentsInlinePyg
    \pytx@MakePygmentsEnvPyg
    \pytx@MakePygmentsInputPyg
    \booltrue{pytx@usedpygments}
}%
\@onlypreamble\makepygmentspyg
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\makepygmentsfv}
% This macro creates the Pygments commands and environment using |fancyvrb|, as a fallback when Pygments is unavailable or when the user desires maximum speed.
%    \begin{macrocode}
\def\makepygmentsfv{%
    \pytx@MakePygmentsInline
    \pytx@MakePygmentsEnv    
    \pytx@MakePygmentsInput
}%
\@onlypreamble\makepygmentsfv
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\makepygments}
% This macro uses the two preceding macros to conditionally define the Pygments commands and environments, based on the package Pygments settings as well as the |\setpygmentsformatter| command that may be used to override the package settings.
%    \begin{macrocode}
\def\makepygments{%
    \AtBeginDocument{%
        \ifdefstring{\pytx@macroformatter@PYG}{auto}%
            {\ifbool{pytx@opt@pygments}%
                {\makepygmentspyg}{\makepygmentsfv}}{}
        \ifdefstring{\pytx@macroformatter@PYG}{pygments}%
            {\makepygmentspyg}{}
        \ifdefstring{\pytx@macroformatter@PYG}{fancyvrb}%
            {\makepygmentsfv}{}
    }%
}%
\@onlypreamble\makepygments
%    \end{macrocode}
% \end{macro}
%
% We conclude by actually creating the Pygments commands and environments.
%    \begin{macrocode}
\makepygments
%    \end{macrocode}
%
% \iffalse
%</package>
% \fi
%
% \Finale
\endinput
